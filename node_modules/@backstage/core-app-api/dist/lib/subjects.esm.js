import ObservableImpl from 'zen-observable';

var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
class PublishSubject {
  constructor() {
    __publicField(this, "isClosed", false);
    __publicField(this, "terminatingError");
    __publicField(this, "observable", new ObservableImpl((subscriber) => {
      if (this.isClosed) {
        if (this.terminatingError) {
          subscriber.error(this.terminatingError);
        } else {
          subscriber.complete();
        }
        return () => {
        };
      }
      this.subscribers.add(subscriber);
      return () => {
        this.subscribers.delete(subscriber);
      };
    }));
    __publicField(this, "subscribers", /* @__PURE__ */ new Set());
  }
  [Symbol.observable]() {
    return this;
  }
  get closed() {
    return this.isClosed;
  }
  next(value) {
    if (this.isClosed) {
      throw new Error("PublishSubject is closed");
    }
    this.subscribers.forEach((subscriber) => subscriber.next(value));
  }
  error(error) {
    if (this.isClosed) {
      throw new Error("PublishSubject is closed");
    }
    this.isClosed = true;
    this.terminatingError = error;
    this.subscribers.forEach((subscriber) => subscriber.error(error));
  }
  complete() {
    if (this.isClosed) {
      throw new Error("PublishSubject is closed");
    }
    this.isClosed = true;
    this.subscribers.forEach((subscriber) => subscriber.complete());
  }
  subscribe(onNext, onError, onComplete) {
    const observer = typeof onNext === "function" ? {
      next: onNext,
      error: onError,
      complete: onComplete
    } : onNext;
    return this.observable.subscribe(observer);
  }
}
class BehaviorSubject {
  constructor(value) {
    __publicField(this, "isClosed");
    __publicField(this, "currentValue");
    __publicField(this, "terminatingError");
    __publicField(this, "observable");
    __publicField(this, "subscribers", /* @__PURE__ */ new Set());
    this.isClosed = false;
    this.currentValue = value;
    this.terminatingError = void 0;
    this.observable = new ObservableImpl((subscriber) => {
      if (this.isClosed) {
        if (this.terminatingError) {
          subscriber.error(this.terminatingError);
        } else {
          subscriber.complete();
        }
        return () => {
        };
      }
      subscriber.next(this.currentValue);
      this.subscribers.add(subscriber);
      return () => {
        this.subscribers.delete(subscriber);
      };
    });
  }
  [Symbol.observable]() {
    return this;
  }
  get closed() {
    return this.isClosed;
  }
  next(value) {
    if (this.isClosed) {
      throw new Error("BehaviorSubject is closed");
    }
    this.currentValue = value;
    this.subscribers.forEach((subscriber) => subscriber.next(value));
  }
  error(error) {
    if (this.isClosed) {
      throw new Error("BehaviorSubject is closed");
    }
    this.isClosed = true;
    this.terminatingError = error;
    this.subscribers.forEach((subscriber) => subscriber.error(error));
  }
  complete() {
    if (this.isClosed) {
      throw new Error("BehaviorSubject is closed");
    }
    this.isClosed = true;
    this.subscribers.forEach((subscriber) => subscriber.complete());
  }
  subscribe(onNext, onError, onComplete) {
    const observer = typeof onNext === "function" ? {
      next: onNext,
      error: onError,
      complete: onComplete
    } : onNext;
    return this.observable.subscribe(observer);
  }
}

export { BehaviorSubject, PublishSubject };
//# sourceMappingURL=subjects.esm.js.map
