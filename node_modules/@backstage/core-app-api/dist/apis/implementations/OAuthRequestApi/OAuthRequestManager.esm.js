import { OAuthPendingRequests } from './OAuthPendingRequests.esm.js';
import { BehaviorSubject } from '../../../lib/subjects.esm.js';

var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
class OAuthRequestManager {
  constructor() {
    __publicField(this, "subject", new BehaviorSubject([]));
    __publicField(this, "currentRequests", []);
    __publicField(this, "handlerCount", 0);
  }
  createAuthRequester(options) {
    const handler = new OAuthPendingRequests();
    const index = this.handlerCount;
    this.handlerCount++;
    handler.pending().subscribe({
      next: (scopeRequest) => {
        const newRequests = this.currentRequests.slice();
        const request = this.makeAuthRequest(scopeRequest, options);
        if (!request) {
          delete newRequests[index];
        } else {
          newRequests[index] = request;
        }
        this.currentRequests = newRequests;
        this.subject.next(newRequests.filter(Boolean));
      }
    });
    return (scopes) => {
      return handler.request(scopes);
    };
  }
  // Converts the pending request and popup options into a popup request that we can forward to subscribers.
  makeAuthRequest(request, options) {
    const { scopes } = request;
    if (!scopes) {
      return void 0;
    }
    return {
      provider: options.provider,
      trigger: async () => {
        const result = await options.onAuthRequest(scopes);
        request.resolve(result);
      },
      reject: () => {
        const error = new Error("Login failed, rejected by user");
        error.name = "RejectedError";
        request.reject(error);
      }
    };
  }
  authRequest$() {
    return this.subject;
  }
}

export { OAuthRequestManager };
//# sourceMappingURL=OAuthRequestManager.esm.js.map
