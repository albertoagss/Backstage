import { startCookieAuthRefresh } from './startCookieAuthRefresh.esm.js';

var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  member.set(obj, value);
  return value;
};
var _cookieAuthSignOut;
function mkError(thing) {
  return new Error(
    `Tried to access IdentityApi ${thing} before app was loaded`
  );
}
function logDeprecation(thing) {
  console.warn(
    `WARNING: Call to ${thing} is deprecated and will break in the future`
  );
}
class AppIdentityProxy {
  constructor() {
    __publicField(this, "target");
    __publicField(this, "waitForTarget");
    __publicField(this, "resolveTarget", () => {
    });
    __publicField(this, "signOutTargetUrl", "/");
    __privateAdd(this, _cookieAuthSignOut, void 0);
    this.waitForTarget = new Promise((resolve) => {
      this.resolveTarget = resolve;
    });
  }
  // This is called by the app manager once the sign-in page provides us with an implementation
  setTarget(identityApi, targetOptions) {
    this.target = identityApi;
    this.signOutTargetUrl = targetOptions.signOutTargetUrl;
    this.resolveTarget(identityApi);
  }
  getUserId() {
    if (!this.target) {
      throw mkError("getUserId");
    }
    if (!this.target.getUserId) {
      throw new Error("IdentityApi does not implement getUserId");
    }
    logDeprecation("getUserId");
    return this.target.getUserId();
  }
  getProfile() {
    if (!this.target) {
      throw mkError("getProfile");
    }
    if (!this.target.getProfile) {
      throw new Error("IdentityApi does not implement getProfile");
    }
    logDeprecation("getProfile");
    return this.target.getProfile();
  }
  async getProfileInfo() {
    return this.waitForTarget.then((target) => target.getProfileInfo());
  }
  async getBackstageIdentity() {
    const identity = await this.waitForTarget.then(
      (target) => target.getBackstageIdentity()
    );
    if (!identity.userEntityRef.match(/^.*:.*\/.*$/)) {
      console.warn(
        `WARNING: The App IdentityApi provided an invalid userEntityRef, '${identity.userEntityRef}'. It must be a full Entity Reference of the form '<kind>:<namespace>/<name>'.`
      );
    }
    return identity;
  }
  async getCredentials() {
    return this.waitForTarget.then((target) => target.getCredentials());
  }
  async getIdToken() {
    return this.waitForTarget.then((target) => {
      if (!target.getIdToken) {
        throw new Error("IdentityApi does not implement getIdToken");
      }
      logDeprecation("getIdToken");
      return target.getIdToken();
    });
  }
  async signOut() {
    var _a;
    await this.waitForTarget.then((target) => target.signOut());
    await ((_a = __privateGet(this, _cookieAuthSignOut)) == null ? void 0 : _a.call(this));
    window.location.href = this.signOutTargetUrl;
  }
  enableCookieAuth(ctx) {
    if (__privateGet(this, _cookieAuthSignOut)) {
      return;
    }
    const stopRefresh = startCookieAuthRefresh(ctx);
    __privateSet(this, _cookieAuthSignOut, async () => {
      stopRefresh();
      const appBaseUrl = await ctx.discoveryApi.getBaseUrl("app");
      try {
        await ctx.fetchApi.fetch(`${appBaseUrl}/.backstage/auth/v1/cookie`, {
          method: "DELETE"
        });
      } catch {
      }
    });
  }
}
_cookieAuthSignOut = new WeakMap();

export { AppIdentityProxy };
//# sourceMappingURL=AppIdentityProxy.esm.js.map
