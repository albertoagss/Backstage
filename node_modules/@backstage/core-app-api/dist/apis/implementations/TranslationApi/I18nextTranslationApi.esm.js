import { createInstance } from 'i18next';
import ObservableImpl from 'zen-observable';
import { toInternalTranslationResource } from '../../../core-plugin-api/src/translation/TranslationResource.esm.js';
import { toInternalTranslationRef } from '../../../core-plugin-api/src/translation/TranslationRef.esm.js';
import { DEFAULT_LANGUAGE } from '../AppLanguageApi/AppLanguageSelector.esm.js';

var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  member.set(obj, value);
  return value;
};
var __privateMethod = (obj, member, method) => {
  __accessCheck(obj, member, "access private method");
  return method;
};
var _loaded, _loading, _loaders, _getLoaderKey, getLoaderKey_fn, _i18n, _loader, _language, _registeredRefs, _languageChangeListeners, _changeLanguage, changeLanguage_fn, _createSnapshot, createSnapshot_fn, _registerDefaults, registerDefaults_fn;
function removeNulls(messages) {
  return Object.fromEntries(
    Object.entries(messages).filter(
      (e) => e[1] !== null
    )
  );
}
class ResourceLoader {
  constructor(onLoad) {
    this.onLoad = onLoad;
    __privateAdd(this, _getLoaderKey);
    /** Loaded resources by loader key */
    __privateAdd(this, _loaded, /* @__PURE__ */ new Set());
    /** Resource loading promises by loader key */
    __privateAdd(this, _loading, /* @__PURE__ */ new Map());
    /** Loaders for each resource language */
    __privateAdd(this, _loaders, /* @__PURE__ */ new Map());
  }
  addTranslationResource(resource) {
    const internalResource = toInternalTranslationResource(resource);
    for (const entry of internalResource.resources) {
      const key = __privateMethod(this, _getLoaderKey, getLoaderKey_fn).call(this, entry.language, internalResource.id);
      if (!__privateGet(this, _loaders).has(key)) {
        __privateGet(this, _loaders).set(key, entry.loader);
      }
    }
  }
  needsLoading(language, namespace) {
    const key = __privateMethod(this, _getLoaderKey, getLoaderKey_fn).call(this, language, namespace);
    const loader = __privateGet(this, _loaders).get(key);
    if (!loader) {
      return false;
    }
    return !__privateGet(this, _loaded).has(key);
  }
  async load(language, namespace) {
    const key = __privateMethod(this, _getLoaderKey, getLoaderKey_fn).call(this, language, namespace);
    const loader = __privateGet(this, _loaders).get(key);
    if (!loader) {
      return;
    }
    if (__privateGet(this, _loaded).has(key)) {
      return;
    }
    const loading = __privateGet(this, _loading).get(key);
    if (loading) {
      await loading;
      return;
    }
    const load = loader().then(
      (result) => {
        this.onLoad({ language, namespace, messages: result.messages });
        __privateGet(this, _loaded).add(key);
      },
      (error) => {
        __privateGet(this, _loaded).add(key);
        throw error;
      }
    );
    __privateGet(this, _loading).set(key, load);
    await load;
  }
}
_loaded = new WeakMap();
_loading = new WeakMap();
_loaders = new WeakMap();
_getLoaderKey = new WeakSet();
getLoaderKey_fn = function(language, namespace) {
  return `${language}/${namespace}`;
};
const _I18nextTranslationApi = class _I18nextTranslationApi {
  constructor(i18n, loader, language) {
    __privateAdd(this, _changeLanguage);
    __privateAdd(this, _createSnapshot);
    __privateAdd(this, _registerDefaults);
    __privateAdd(this, _i18n, void 0);
    __privateAdd(this, _loader, void 0);
    __privateAdd(this, _language, void 0);
    /** Keep track of which refs we have registered default resources for */
    __privateAdd(this, _registeredRefs, /* @__PURE__ */ new Set());
    /** Notify observers when language changes */
    __privateAdd(this, _languageChangeListeners, /* @__PURE__ */ new Set());
    __privateSet(this, _i18n, i18n);
    __privateSet(this, _loader, loader);
    __privateSet(this, _language, language);
  }
  static create(options) {
    const { languages } = options.languageApi.getAvailableLanguages();
    const i18n = createInstance({
      fallbackLng: DEFAULT_LANGUAGE,
      supportedLngs: languages,
      interpolation: {
        escapeValue: false
      },
      ns: [],
      defaultNS: false,
      fallbackNS: false,
      // Disable resource loading on init, meaning i18n will be ready to use immediately
      initImmediate: false
    });
    i18n.init();
    if (!i18n.isInitialized) {
      throw new Error("i18next was unexpectedly not initialized");
    }
    const { language: initialLanguage } = options.languageApi.getLanguage();
    if (initialLanguage !== DEFAULT_LANGUAGE) {
      i18n.changeLanguage(initialLanguage);
    }
    const loader = new ResourceLoader((loaded) => {
      i18n.addResourceBundle(
        loaded.language,
        loaded.namespace,
        removeNulls(loaded.messages),
        false,
        // do not merge with existing translations
        true
        // overwrite translations
      );
    });
    const resources = (options == null ? void 0 : options.resources) || [];
    for (let i = resources.length - 1; i >= 0; i--) {
      const resource = resources[i];
      if (resource.$$type === "@backstage/TranslationResource") {
        loader.addTranslationResource(resource);
      } else if (resource.$$type === "@backstage/TranslationMessages") {
        i18n.addResourceBundle(
          DEFAULT_LANGUAGE,
          resource.id,
          removeNulls(resource.messages),
          true,
          // merge with existing translations
          false
          // do not overwrite translations
        );
      }
    }
    const instance = new _I18nextTranslationApi(
      i18n,
      loader,
      options.languageApi.getLanguage().language
    );
    options.languageApi.language$().subscribe(({ language }) => {
      var _a;
      __privateMethod(_a = instance, _changeLanguage, changeLanguage_fn).call(_a, language);
    });
    return instance;
  }
  getTranslation(translationRef) {
    const internalRef = toInternalTranslationRef(translationRef);
    __privateMethod(this, _registerDefaults, registerDefaults_fn).call(this, internalRef);
    return __privateMethod(this, _createSnapshot, createSnapshot_fn).call(this, internalRef);
  }
  translation$(translationRef) {
    const internalRef = toInternalTranslationRef(translationRef);
    __privateMethod(this, _registerDefaults, registerDefaults_fn).call(this, internalRef);
    return new ObservableImpl((subscriber) => {
      let loadTicket = {};
      const loadResource = () => {
        loadTicket = {};
        const ticket = loadTicket;
        __privateGet(this, _loader).load(__privateGet(this, _language), internalRef.id).then(
          () => {
            if (ticket === loadTicket) {
              const snapshot = __privateMethod(this, _createSnapshot, createSnapshot_fn).call(this, internalRef);
              if (snapshot.ready) {
                subscriber.next(snapshot);
              }
            }
          },
          (error) => {
            if (ticket === loadTicket) {
              subscriber.error(Array.isArray(error) ? error[0] : error);
            }
          }
        );
      };
      const onChange = () => {
        const snapshot = __privateMethod(this, _createSnapshot, createSnapshot_fn).call(this, internalRef);
        if (snapshot.ready) {
          subscriber.next(snapshot);
        } else {
          loadResource();
        }
      };
      if (__privateGet(this, _loader).needsLoading(__privateGet(this, _language), internalRef.id)) {
        loadResource();
      }
      __privateGet(this, _languageChangeListeners).add(onChange);
      return () => {
        __privateGet(this, _languageChangeListeners).delete(onChange);
      };
    });
  }
};
_i18n = new WeakMap();
_loader = new WeakMap();
_language = new WeakMap();
_registeredRefs = new WeakMap();
_languageChangeListeners = new WeakMap();
_changeLanguage = new WeakSet();
changeLanguage_fn = function(language) {
  if (__privateGet(this, _language) !== language) {
    __privateSet(this, _language, language);
    __privateGet(this, _i18n).changeLanguage(language);
    __privateGet(this, _languageChangeListeners).forEach((listener) => listener());
  }
};
_createSnapshot = new WeakSet();
createSnapshot_fn = function(internalRef) {
  if (__privateGet(this, _loader).needsLoading(__privateGet(this, _language), internalRef.id)) {
    return { ready: false };
  }
  const t = __privateGet(this, _i18n).getFixedT(
    null,
    internalRef.id
  );
  return {
    ready: true,
    t
  };
};
_registerDefaults = new WeakSet();
registerDefaults_fn = function(internalRef) {
  if (__privateGet(this, _registeredRefs).has(internalRef.id)) {
    return;
  }
  __privateGet(this, _registeredRefs).add(internalRef.id);
  const defaultMessages = internalRef.getDefaultMessages();
  __privateGet(this, _i18n).addResourceBundle(
    DEFAULT_LANGUAGE,
    internalRef.id,
    defaultMessages,
    true,
    // merge with existing translations
    false
    // do not overwrite translations
  );
  const defaultResource = internalRef.getDefaultResource();
  if (defaultResource) {
    __privateGet(this, _loader).addTranslationResource(defaultResource);
  }
};
let I18nextTranslationApi = _I18nextTranslationApi;

export { I18nextTranslationApi };
//# sourceMappingURL=I18nextTranslationApi.esm.js.map
