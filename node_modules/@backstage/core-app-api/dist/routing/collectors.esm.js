import { getComponentData } from '@backstage/core-plugin-api';
import { isValidElement, Children } from 'react';
import { createCollector } from '../extensions/traversal.esm.js';
import { FeatureFlagged } from './FeatureFlagged.esm.js';

const MATCH_ALL_ROUTE = {
  caseSensitive: false,
  path: "*",
  element: "match-all",
  // These elements aren't used, so we add in a bit of debug information
  routeRefs: /* @__PURE__ */ new Set(),
  plugins: /* @__PURE__ */ new Set()
};
function stringifyNode(node) {
  var _a, _b;
  const anyNode = node;
  if (anyNode == null ? void 0 : anyNode.type) {
    return (_b = (_a = anyNode.type.displayName) != null ? _a : anyNode.type.name) != null ? _b : String(anyNode.type);
  }
  return String(anyNode);
}
const pluginSet = (plugin) => {
  const set = /* @__PURE__ */ new Set();
  if (plugin) {
    set.add(plugin);
  }
  return set;
};
function collectSubTree(node, entries = new Array()) {
  Children.forEach(node, (element) => {
    if (!isValidElement(element)) {
      return;
    }
    const routeRef = getComponentData(element, "core.mountPoint");
    if (routeRef) {
      const plugin = getComponentData(element, "core.plugin");
      entries.push({ routeRef, plugin });
    }
    collectSubTree(element.props.children, entries);
  });
  return entries;
}
const routingV2Collector = createCollector(
  () => ({
    paths: /* @__PURE__ */ new Map(),
    parents: /* @__PURE__ */ new Map(),
    objects: new Array()
  }),
  (acc, node, parent, ctx) => {
    var _a, _b, _c, _d, _e, _f, _g;
    if (ctx == null ? void 0 : ctx.isElementAncestor) {
      return ctx;
    }
    if ((parent == null ? void 0 : parent.props.element) === node) {
      return { ...ctx, isElementAncestor: true };
    }
    const pathProp = (_a = node.props) == null ? void 0 : _a.path;
    const mountPoint = getComponentData(node, "core.mountPoint");
    if (mountPoint && pathProp) {
      throw new Error(
        `Path property may not be set directly on a routable extension "${stringifyNode(
          node
        )}"`
      );
    }
    const parentChildren = (_c = (_b = ctx == null ? void 0 : ctx.obj) == null ? void 0 : _b.children) != null ? _c : acc.objects;
    if (pathProp !== void 0) {
      if (typeof pathProp !== "string") {
        throw new Error(
          `Element path must be a string at "${stringifyNode(node)}"`
        );
      }
      const path = pathProp.startsWith("/") ? pathProp.slice(1) : pathProp;
      const elementProp = node.props.element;
      if (getComponentData(node, "core.gatherMountPoints")) {
        if (elementProp) {
          throw new Error(
            `Mount point gatherers may not have an element prop "${stringifyNode(
              node
            )}"`
          );
        }
        const newObj = {
          path,
          element: "gathered",
          routeRefs: /* @__PURE__ */ new Set(),
          caseSensitive: Boolean((_d = node.props) == null ? void 0 : _d.caseSensitive),
          children: [MATCH_ALL_ROUTE],
          plugins: /* @__PURE__ */ new Set()
        };
        parentChildren.push(newObj);
        return {
          obj: newObj,
          gatherPath: path,
          routeRef: ctx == null ? void 0 : ctx.routeRef,
          gatherRouteRef: ctx == null ? void 0 : ctx.routeRef
        };
      }
      if (elementProp) {
        const [extension, ...others] = collectSubTree(elementProp);
        if (others.length > 0) {
          throw new Error(
            `Route element with path "${pathProp}" may not contain multiple routable extensions`
          );
        }
        if (!extension) {
          return ctx;
        }
        const { routeRef, plugin } = extension;
        const newObj = {
          path,
          element: "mounted",
          routeRefs: /* @__PURE__ */ new Set([routeRef]),
          caseSensitive: Boolean((_e = node.props) == null ? void 0 : _e.caseSensitive),
          children: [MATCH_ALL_ROUTE],
          plugins: pluginSet(plugin)
        };
        parentChildren.push(newObj);
        acc.paths.set(routeRef, path);
        acc.parents.set(routeRef, ctx == null ? void 0 : ctx.routeRef);
        return {
          obj: newObj,
          routeRef: routeRef != null ? routeRef : ctx == null ? void 0 : ctx.routeRef,
          gatherPath: path,
          gatherRouteRef: ctx == null ? void 0 : ctx.gatherRouteRef
        };
      }
    }
    if (mountPoint) {
      if ((ctx == null ? void 0 : ctx.gatherPath) === void 0) {
        throw new Error(
          `Routable extension "${stringifyNode(
            node
          )}" with mount point "${mountPoint}" must be assigned a path`
        );
      }
      (_f = ctx == null ? void 0 : ctx.obj) == null ? void 0 : _f.routeRefs.add(mountPoint);
      const mountPointPlugin = getComponentData(
        node,
        "core.plugin"
      );
      if (mountPointPlugin) {
        (_g = ctx == null ? void 0 : ctx.obj) == null ? void 0 : _g.plugins.add(mountPointPlugin);
      }
      acc.paths.set(mountPoint, ctx.gatherPath);
      acc.parents.set(mountPoint, ctx == null ? void 0 : ctx.gatherRouteRef);
      return {
        ...ctx,
        routeRef: mountPoint
      };
    }
    return ctx;
  }
);
const routingV1Collector = createCollector(
  () => ({
    paths: /* @__PURE__ */ new Map(),
    parents: /* @__PURE__ */ new Map(),
    objects: new Array()
  }),
  (acc, node, parent, ctx) => {
    var _a, _b, _c, _d, _e;
    if ((parent == null ? void 0 : parent.props.element) === node) {
      return ctx;
    }
    let currentObj = ctx == null ? void 0 : ctx.obj;
    let currentParentRouteRef = ctx == null ? void 0 : ctx.routeRef;
    let sticky = ctx == null ? void 0 : ctx.sticky;
    const path = (_a = node.props) == null ? void 0 : _a.path;
    const parentChildren = (_b = currentObj == null ? void 0 : currentObj.children) != null ? _b : acc.objects;
    const caseSensitive = Boolean((_c = node.props) == null ? void 0 : _c.caseSensitive);
    let currentCtxPath = ctx == null ? void 0 : ctx.path;
    if (getComponentData(node, "core.gatherMountPoints")) {
      if (!path) {
        throw new Error("Mount point gatherer must have a path");
      }
      currentCtxPath = path;
    }
    const element = (_d = node.props) == null ? void 0 : _d.element;
    let routeRef = getComponentData(node, "core.mountPoint");
    if (!routeRef && isValidElement(element)) {
      routeRef = getComponentData(element, "core.mountPoint");
    }
    if (routeRef) {
      let routePath = path;
      if (currentCtxPath) {
        if (routePath) {
          currentCtxPath = void 0;
        } else {
          routePath = currentCtxPath;
        }
      }
      if (!routePath) {
        throw new Error("Mounted routable extension must have a path");
      }
      acc.paths.set(routeRef, routePath);
      if (currentParentRouteRef && sticky) {
        acc.parents.set(routeRef, currentParentRouteRef);
        if (path) {
          currentParentRouteRef = routeRef;
          sticky = false;
        }
      } else {
        acc.parents.set(routeRef, currentParentRouteRef);
        currentParentRouteRef = routeRef;
      }
      if (path) {
        currentObj = {
          caseSensitive,
          path,
          element: "mounted",
          routeRefs: /* @__PURE__ */ new Set([routeRef]),
          children: [MATCH_ALL_ROUTE],
          plugins: pluginSet(
            getComponentData(
              node.props.element,
              "core.plugin"
            )
          )
        };
        parentChildren.push(currentObj);
      } else {
        currentObj == null ? void 0 : currentObj.routeRefs.add(routeRef);
      }
    }
    if (getComponentData(node, "core.gatherMountPoints")) {
      sticky = true;
    }
    const isGatherer = getComponentData(
      node,
      "core.gatherMountPoints"
    );
    if (isGatherer) {
      if (!path) {
        throw new Error("Mount point gatherer must have a path");
      }
      if (!routeRef) {
        currentObj = {
          caseSensitive,
          path,
          element: "gathered",
          routeRefs: /* @__PURE__ */ new Set(),
          children: [MATCH_ALL_ROUTE],
          plugins: ((_e = ctx == null ? void 0 : ctx.obj) == null ? void 0 : _e.plugins) || /* @__PURE__ */ new Set()
        };
        parentChildren.push(currentObj);
      }
    }
    return {
      obj: currentObj,
      path: currentCtxPath,
      routeRef: currentParentRouteRef,
      sticky
    };
  }
);
const featureFlagCollector = createCollector(
  () => /* @__PURE__ */ new Set(),
  (acc, node) => {
    if (node.type === FeatureFlagged) {
      const props = node.props;
      acc.add("with" in props ? props.with : props.without);
    }
  }
);

export { MATCH_ALL_ROUTE, featureFlagCollector, routingV1Collector, routingV2Collector };
//# sourceMappingURL=collectors.esm.js.map
