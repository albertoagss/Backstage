import { Children, isValidElement } from 'react';

function traverseElementTree(options) {
  const collectors = {};
  for (const name in options.collectors) {
    if (options.collectors.hasOwnProperty(name)) {
      collectors[name] = options.collectors[name]();
    }
  }
  const queue = [
    {
      node: Children.toArray(options.root),
      parent: void 0,
      contexts: {}
    }
  ];
  while (queue.length !== 0) {
    const { node, parent, contexts } = queue.shift();
    Children.forEach(node, (element) => {
      if (!isValidElement(element)) {
        return;
      }
      const nextContexts = {};
      for (const name in collectors) {
        if (collectors.hasOwnProperty(name)) {
          const collector = collectors[name];
          nextContexts[name] = collector.visit(
            collector.accumulator,
            element,
            parent,
            contexts[name]
          );
        }
      }
      for (const discoverer of options.discoverers) {
        const children = discoverer(element);
        if (children) {
          queue.push({
            node: children,
            parent: element,
            contexts: nextContexts
          });
        }
      }
    });
  }
  return Object.fromEntries(
    Object.entries(collectors).map(([name, c]) => [name, c.accumulator])
  );
}
function createCollector(accumulatorFactory, visit) {
  return () => ({ accumulator: accumulatorFactory(), visit });
}
function childDiscoverer(element) {
  var _a;
  return (_a = element.props) == null ? void 0 : _a.children;
}
function routeElementDiscoverer(element) {
  var _a, _b, _c;
  if (((_a = element.props) == null ? void 0 : _a.path) && ((_b = element.props) == null ? void 0 : _b.element)) {
    return (_c = element.props) == null ? void 0 : _c.element;
  }
  return void 0;
}

export { childDiscoverer, createCollector, routeElementDiscoverer, traverseElementTree };
//# sourceMappingURL=traversal.esm.js.map
