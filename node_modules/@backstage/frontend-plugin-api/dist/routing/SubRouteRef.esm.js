import { toInternalRouteRef } from './RouteRef.esm.js';

var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  member.set(obj, value);
  return value;
};
var _params, _parent;
const PARAM_PATTERN = /^\w+$/;
class SubRouteRefImpl {
  constructor(path, params, parent) {
    this.path = path;
    __publicField(this, "$$type", "@backstage/SubRouteRef");
    __publicField(this, "version", "v1");
    __privateAdd(this, _params, void 0);
    __privateAdd(this, _parent, void 0);
    __privateSet(this, _params, params);
    __privateSet(this, _parent, parent);
  }
  getParams() {
    return __privateGet(this, _params);
  }
  getParent() {
    return __privateGet(this, _parent);
  }
  getDescription() {
    const parent = toInternalRouteRef(__privateGet(this, _parent));
    return `at ${this.path} with parent ${parent.getDescription()}`;
  }
  toString() {
    return `SubRouteRef{${this.getDescription()}}`;
  }
}
_params = new WeakMap();
_parent = new WeakMap();
function createSubRouteRef(config) {
  const { path, parent } = config;
  const internalParent = toInternalRouteRef(parent);
  const parentParams = internalParent.getParams();
  const pathParams = path.split("/").filter((p) => p.startsWith(":")).map((p) => p.substring(1));
  const params = [...parentParams, ...pathParams];
  if (parentParams.some((p) => pathParams.includes(p))) {
    throw new Error(
      "SubRouteRef may not have params that overlap with its parent"
    );
  }
  if (!path.startsWith("/")) {
    throw new Error(`SubRouteRef path must start with '/', got '${path}'`);
  }
  if (path.endsWith("/")) {
    throw new Error(`SubRouteRef path must not end with '/', got '${path}'`);
  }
  for (const param of pathParams) {
    if (!PARAM_PATTERN.test(param)) {
      throw new Error(`SubRouteRef path has invalid param, got '${param}'`);
    }
  }
  const subRouteRef = new SubRouteRefImpl(
    path,
    params,
    parent
  );
  return subRouteRef;
}

export { SubRouteRefImpl, createSubRouteRef };
//# sourceMappingURL=SubRouteRef.esm.js.map
