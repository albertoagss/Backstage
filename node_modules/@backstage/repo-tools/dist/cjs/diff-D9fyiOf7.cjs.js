'use strict';

var cliNode = require('@backstage/cli-node');
var exec = require('./exec-B_ZXslMw.cjs.js');
var openapiUtilities = require('@useoptic/openapi-utilities');
var paths = require('./paths-BvbxdT_S.cjs.js');
var constants = require('./constants-Dwa51b6l.cjs.js');
require('util');
require('child_process');
require('@backstage/cli-common');
require('minimatch');
require('path');

const getChecksLabel = (results, severity) => {
  const totalChecks = results.length;
  let failingChecks = 0;
  let exemptedFailingChecks = 0;
  for (const result of results) {
    if (result.passed)
      continue;
    if (result.severity < severity)
      continue;
    if (result.exempted)
      exemptedFailingChecks += 1;
    else
      failingChecks += 1;
  }
  const exemptedChunk = exemptedFailingChecks > 0 ? `, ${exemptedFailingChecks} exempted` : "";
  return failingChecks > 0 ? `\u26A0\uFE0F **${failingChecks}**/**${totalChecks}** failed${exemptedChunk}` : totalChecks > 0 ? `\u2705 **${totalChecks}** passed${exemptedChunk}` : `\u2139\uFE0F No automated checks have run`;
};
function getOperationsText(groupedDiffs, options) {
  const ops = openapiUtilities.getOperationsChanged(groupedDiffs);
  const operationsText = [
    ...[...ops.added].map((o) => `\`${o}\` (added)`),
    ...[...ops.changed].map((o) => `\`${o}\` (changed)`),
    ...[...ops.removed].map((o) => `\`${o}\` (removed)`)
  ].join("\n") ;
  return `${openapiUtilities.getOperationsChangedLabel(groupedDiffs)}
    
      ${operationsText}
    `;
}
const getCaptureIssuesLabel = ({
  unmatchedInteractions,
  mismatchedEndpoints
}) => {
  return [
    ...unmatchedInteractions ? [
      `\u{1F195} ${unmatchedInteractions} undocumented path${unmatchedInteractions > 1 ? "s" : ""}`
    ] : [],
    ...mismatchedEndpoints ? [
      `\u26A0\uFE0F  ${mismatchedEndpoints} mismatch${mismatchedEndpoints > 1 ? "es" : ""}`
    ] : []
  ].join("\n");
};
const getBreakagesRow = (breakage) => {
  return `
  - ${breakage.apiName}
  ${breakage.comparison.results.map(
    (s) => `
    - ${s.where}
      ${"```"}
      ${s.error}
      ${"```"}`
  )}`;
};
const addSummaryLine = (items, label) => {
  const length = Array.isArray(items) ? items.length : items;
  if (!length)
    return "";
  let text = length === 1 ? `1 API` : `${length} APIs`;
  text += ` had ${label}`;
  return text;
};
const generateCompareSummaryMarkdown = (commit, results, options) => {
  const anyCompletedHasWarning = results.completed.some(
    (s) => s.warnings.length > 0
  );
  const anyCompletedHasCapture = results.completed.some((s) => s.capture);
  if (results.completed.length === 0 && results.failed.length === 0 && results.failed.length === 0) {
    return `No API changes detected for commit (${commit.sha})`;
  }
  const breakages = results.completed.filter((s) => s.comparison.results.some((e) => !e.passed)).map((e) => ({
    ...e,
    comparison: {
      ...e.comparison,
      results: e.comparison.results.filter((f) => !f.passed)
    }
  }));
  const successfullyCompletedCount = results.completed.length - breakages.length;
  return `### Summary for commit (${commit.sha})

${addSummaryLine(results.noop, "no changes")}

${addSummaryLine(breakages.length, "breaking changes")}

${addSummaryLine(successfullyCompletedCount, "non-breaking changes")}

${addSummaryLine(results.warning, "warnings")}

${results.completed.length > 0 ? `### APIs with Changes

<table>
<thead>
<tr>
<th>API</th>
<th>Changes</th>
<th>Rules</th>
${anyCompletedHasWarning ? "<th>Warnings</th>" : ""}
${anyCompletedHasCapture ? "<th>Tests</th>" : ""}
</tr>
</thead>
<tbody>
${results.completed.map(
    (s) => `<tr>
<td>
${s.apiName}
</td>
<td>
${getOperationsText(s.comparison.groupedDiffs, {
      webUrl: s.opticWebUrl,
      verbose: options.verbose,
      labelJoiner: ",\n"
    })}
</td>
<td>
${getChecksLabel(s.comparison.results, results.severity)}
</td>

${anyCompletedHasWarning ? `<td>${s.warnings.join("\n")}</td>` : ""}

${anyCompletedHasCapture ? `
<td>
${s.capture ? s.capture.success ? s.capture.mismatchedEndpoints || s.capture.unmatchedInteractions ? getCaptureIssuesLabel({
      unmatchedInteractions: s.capture.unmatchedInteractions,
      mismatchedEndpoints: s.capture.mismatchedEndpoints
    }) : `\u2705 ${s.capture.percentCovered}% coverage` : "\u274C\xA0Failed to run" : ""}
</td>
` : ""}
</tr>`
  ).join("\n")}
</tbody>
</table>` : ""}

${results.failed.length > 0 ? `### APIs with Errors

<table>
<thead>
<tr>
<th>API</th>
<th>Error</th>
</tr>
</thead>
<tbody>
${results.failed.map(
    (s) => `<tr>
<td>${s.apiName}</td>
<td>

${"```"}
${s.error}
${"```"}

</td>
</tr>`
  ).join("\n")}
</tbody>
</table>
` : ""}

${results.warning && results.warning.length ? `
### APIs with Warnings
<table>
<thead>
<tr>
<th>API</th>
<th>Warning</th>
</tr>
</thead>
<tbody>
      ${results.warning.map((e) => `<tr><td>${e.apiName}</td><td>${e.warning}</td></tr>`).join("\n")}
</tbody>
</table>` : ""}
${breakages.length > 0 ? `
### Routes with Breakages

${breakages.map(getBreakagesRow).join("\n")}
` : ""}
`;
};

function cleanUpApiName(e) {
  e.apiName = e.apiName.replace(paths.paths.targetDir, "").replace(constants.YAML_SCHEMA_PATH, "");
}
async function command(opts) {
  var _a, _b, _c, _d, _e;
  let packages = await cliNode.PackageGraph.listTargetPackages();
  let since = "";
  if (opts.since) {
    const { stdout: sinceRaw } = await exec.exec("git", ["rev-parse", opts.since]);
    since = sinceRaw.toString().trim();
    const { stdout: changedFilesRaw } = await exec.exec("git", [
      "diff",
      "--name-only",
      since
    ]);
    const changedFiles = changedFilesRaw.toString().trim();
    const changedOpenApiSpecs = changedFiles.split("\n").filter((e) => e.endsWith(constants.YAML_SCHEMA_PATH)).map((e) => paths.paths.resolveTarget(e));
    packages = packages.filter(
      (pkg) => changedOpenApiSpecs.some((e) => e.startsWith(`${pkg.dir}/`))
    );
  }
  const checkablePackages = packages.filter((e) => {
    var _a2;
    return (_a2 = e.packageJson.scripts) == null ? void 0 : _a2.diff;
  });
  try {
    const outputs = {
      completed: [],
      failed: [],
      noop: [],
      warning: [],
      severity: 0
    };
    for (const pkg of checkablePackages) {
      const sinceCommands = since ? ["--since", since] : [];
      const { stdout } = await exec.exec(
        "yarn",
        ["diff", "--ignore", "--json", ...sinceCommands],
        {
          cwd: pkg.dir
        }
      );
      const result = JSON.parse(stdout.toString());
      outputs.completed.push(...(_a = result.completed) != null ? _a : []);
      outputs.failed.push(...(_b = result.failed) != null ? _b : []);
      outputs.noop.push(...(_c = result.noop) != null ? _c : []);
    }
    for (const pkg of packages.filter((e) => {
      var _a2;
      return !((_a2 = e.packageJson.scripts) == null ? void 0 : _a2.diff);
    })) {
      (_d = outputs.warning) == null ? void 0 : _d.push({
        apiName: `${pkg.dir}/`,
        warning: "No diff script found in package.json"
      });
    }
    outputs.completed.forEach(cleanUpApiName);
    outputs.failed.forEach(cleanUpApiName);
    outputs.noop.forEach(cleanUpApiName);
    (_e = outputs.warning) == null ? void 0 : _e.forEach(cleanUpApiName);
    const { stdout: currentSha } = await exec.exec("git", ["rev-parse", "HEAD"]);
    console.log(
      generateCompareSummaryMarkdown(
        { sha: currentSha.toString().trim() },
        outputs,
        { verbose: true }
      )
    );
    const failed = outputs.failed.length > 0;
    if (failed) {
      throw new Error("Some checks failed");
    }
  } catch (err) {
    console.error(err);
    process.exit(1);
  }
}

exports.command = command;
//# sourceMappingURL=diff-D9fyiOf7.cjs.js.map
