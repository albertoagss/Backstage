import { createFetchApi, FetchMiddlewares } from '@backstage/core-app-api';
import crossFetch, { Response } from 'cross-fetch';

var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, key + "" , value);
  return value;
};
class MockFetchApi {
  /**
   * Creates a mock {@link @backstage/core-plugin-api#FetchApi}.
   */
  constructor(options) {
    __publicField(this, "implementation");
    this.implementation = build(options);
  }
  /** {@inheritdoc @backstage/core-plugin-api#FetchApi.fetch} */
  get fetch() {
    return this.implementation.fetch;
  }
}
function build(options) {
  return createFetchApi({
    baseImplementation: baseImplementation(options),
    middleware: [
      resolvePluginProtocol(options),
      injectIdentityAuth(options)
    ].filter((x) => Boolean(x))
  });
}
function baseImplementation(options) {
  const implementation = options == null ? void 0 : options.baseImplementation;
  if (!implementation) {
    return crossFetch;
  } else if (implementation === "none") {
    return () => Promise.resolve(new Response());
  }
  return implementation;
}
function resolvePluginProtocol(allOptions) {
  const options = allOptions == null ? void 0 : allOptions.resolvePluginProtocol;
  if (!options) {
    return void 0;
  }
  return FetchMiddlewares.resolvePluginProtocol({
    discoveryApi: options.discoveryApi
  });
}
function injectIdentityAuth(allOptions) {
  const options = allOptions == null ? void 0 : allOptions.injectIdentityAuth;
  if (!options) {
    return void 0;
  }
  const identityApi = "token" in options ? { getCredentials: async () => ({ token: options.token }) } : options.identityApi;
  return FetchMiddlewares.injectIdentityAuth({
    identityApi,
    allowUrl: () => true
  });
}

export { MockFetchApi };
//# sourceMappingURL=MockFetchApi.esm.js.map
