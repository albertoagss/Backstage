import React, { useMemo, useState, useEffect, useCallback } from 'react';
import { Page, Header, Content, ErrorPanel } from '@backstage/core-components';
import { useParams, useNavigate } from 'react-router-dom';
import Box from '@material-ui/core/Box';
import Button from '@material-ui/core/Button';
import Paper from '@material-ui/core/Paper';
import { makeStyles } from '@material-ui/core/styles';
import { scaffolderApiRef, useTaskEventStream } from '@backstage/plugin-scaffolder-react';
import { selectedTemplateRouteRef } from '../../routes.esm.js';
import { useRouteRef, useAnalytics, useApi } from '@backstage/core-plugin-api';
import qs from 'qs';
import { ContextMenu } from './ContextMenu.esm.js';
import { DefaultTemplateOutputs, TaskSteps, TaskLogStream } from '@backstage/plugin-scaffolder-react/alpha';
import { useAsync } from '@react-hookz/web';

const useStyles = makeStyles((theme) => ({
  contentWrapper: {
    display: "flex",
    flexDirection: "column"
  },
  buttonBar: {
    display: "flex",
    flexDirection: "row",
    justifyContent: "right"
  },
  cancelButton: {
    marginRight: theme.spacing(1)
  },
  logsVisibilityButton: {
    marginRight: theme.spacing(1)
  }
}));
const OngoingTask = (props) => {
  var _a, _b, _c, _d, _e, _f, _g, _h;
  const { taskId } = useParams();
  const templateRouteRef = useRouteRef(selectedTemplateRouteRef);
  const navigate = useNavigate();
  const analytics = useAnalytics();
  const scaffolderApi = useApi(scaffolderApiRef);
  const taskStream = useTaskEventStream(taskId);
  const classes = useStyles();
  const steps = useMemo(
    () => {
      var _a2, _b2;
      return (_b2 = (_a2 = taskStream.task) == null ? void 0 : _a2.spec.steps.map((step) => {
        var _a3;
        return {
          ...step,
          ...(_a3 = taskStream == null ? void 0 : taskStream.steps) == null ? void 0 : _a3[step.id]
        };
      })) != null ? _b2 : [];
    },
    [taskStream]
  );
  const [logsVisible, setLogVisibleState] = useState(false);
  const [buttonBarVisible, setButtonBarVisibleState] = useState(true);
  useEffect(() => {
    if (taskStream.error) {
      setLogVisibleState(true);
    }
  }, [taskStream.error]);
  useEffect(() => {
    if (taskStream.completed && !taskStream.error) {
      setButtonBarVisibleState(false);
    }
  }, [taskStream.error, taskStream.completed]);
  const activeStep = useMemo(() => {
    for (let i = steps.length - 1; i >= 0; i--) {
      if (steps[i].status !== "open") {
        return i;
      }
    }
    return 0;
  }, [steps]);
  const startOver = useCallback(() => {
    var _a2, _b2, _c2, _d2, _e2, _f2;
    const { namespace, name } = (_d2 = (_c2 = (_b2 = (_a2 = taskStream.task) == null ? void 0 : _a2.spec.templateInfo) == null ? void 0 : _b2.entity) == null ? void 0 : _c2.metadata) != null ? _d2 : {};
    const formData = (_f2 = (_e2 = taskStream.task) == null ? void 0 : _e2.spec.parameters) != null ? _f2 : {};
    if (!namespace || !name) {
      return;
    }
    analytics.captureEvent("click", `Task has been started over`);
    navigate({
      pathname: templateRouteRef({
        namespace,
        templateName: name
      }),
      search: `?${qs.stringify({ formData: JSON.stringify(formData) })}`
    });
  }, [
    analytics,
    navigate,
    (_a = taskStream.task) == null ? void 0 : _a.spec.parameters,
    (_d = (_c = (_b = taskStream.task) == null ? void 0 : _b.spec.templateInfo) == null ? void 0 : _c.entity) == null ? void 0 : _d.metadata,
    templateRouteRef
  ]);
  const [{ status: cancelStatus }, { execute: triggerCancel }] = useAsync(
    async () => {
      if (taskId) {
        analytics.captureEvent("cancelled", "Template has been cancelled");
        await scaffolderApi.cancelTask(taskId);
      }
    }
  );
  const Outputs = (_e = props.TemplateOutputsComponent) != null ? _e : DefaultTemplateOutputs;
  const templateName = (_h = (_g = (_f = taskStream.task) == null ? void 0 : _f.spec.templateInfo) == null ? void 0 : _g.entity) == null ? void 0 : _h.metadata.name;
  const cancelEnabled = !(taskStream.cancelled || taskStream.completed);
  return /* @__PURE__ */ React.createElement(Page, { themeId: "website" }, /* @__PURE__ */ React.createElement(
    Header,
    {
      pageTitleOverride: `Run of ${templateName}`,
      title: /* @__PURE__ */ React.createElement("div", null, "Run of ", /* @__PURE__ */ React.createElement("code", null, templateName)),
      subtitle: `Task ${taskId}`
    },
    /* @__PURE__ */ React.createElement(
      ContextMenu,
      {
        cancelEnabled,
        logsVisible,
        buttonBarVisible,
        onStartOver: startOver,
        onToggleLogs: setLogVisibleState,
        onToggleButtonBar: setButtonBarVisibleState,
        taskId
      }
    )
  ), /* @__PURE__ */ React.createElement(Content, { className: classes.contentWrapper }, taskStream.error ? /* @__PURE__ */ React.createElement(Box, { paddingBottom: 2 }, /* @__PURE__ */ React.createElement(
    ErrorPanel,
    {
      error: taskStream.error,
      titleFormat: "markdown",
      title: taskStream.error.message
    }
  )) : null, /* @__PURE__ */ React.createElement(Box, { paddingBottom: 2 }, /* @__PURE__ */ React.createElement(
    TaskSteps,
    {
      steps,
      activeStep,
      isComplete: taskStream.completed,
      isError: Boolean(taskStream.error)
    }
  )), /* @__PURE__ */ React.createElement(Outputs, { output: taskStream.output }), buttonBarVisible ? /* @__PURE__ */ React.createElement(Box, { paddingBottom: 2 }, /* @__PURE__ */ React.createElement(Paper, null, /* @__PURE__ */ React.createElement(Box, { padding: 2 }, /* @__PURE__ */ React.createElement("div", { className: classes.buttonBar }, /* @__PURE__ */ React.createElement(
    Button,
    {
      className: classes.cancelButton,
      disabled: !cancelEnabled || cancelStatus !== "not-executed",
      onClick: triggerCancel,
      "data-testid": "cancel-button"
    },
    "Cancel"
  ), /* @__PURE__ */ React.createElement(
    Button,
    {
      className: classes.logsVisibilityButton,
      color: "primary",
      variant: "outlined",
      onClick: () => setLogVisibleState(!logsVisible)
    },
    logsVisible ? "Hide Logs" : "Show Logs"
  ), /* @__PURE__ */ React.createElement(
    Button,
    {
      variant: "contained",
      color: "primary",
      disabled: cancelEnabled,
      onClick: startOver
    },
    "Start Over"
  ))))) : null, logsVisible ? /* @__PURE__ */ React.createElement(Box, { paddingBottom: 2, height: "100%" }, /* @__PURE__ */ React.createElement(Paper, { style: { height: "100%" } }, /* @__PURE__ */ React.createElement(Box, { padding: 2, height: "100%" }, /* @__PURE__ */ React.createElement(TaskLogStream, { logs: taskStream.stepLogs })))) : null));
};

export { OngoingTask };
//# sourceMappingURL=OngoingTask.esm.js.map
