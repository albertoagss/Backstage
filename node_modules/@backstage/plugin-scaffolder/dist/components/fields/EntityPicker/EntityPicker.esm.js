import { CATALOG_FILTER_EXISTS } from '@backstage/catalog-client';
import { parseEntityRef, stringifyEntityRef } from '@backstage/catalog-model';
import { useApi } from '@backstage/core-plugin-api';
import { catalogApiRef, humanizeEntityRef } from '@backstage/plugin-catalog-react';
import TextField from '@material-ui/core/TextField';
import FormControl from '@material-ui/core/FormControl';
import Autocomplete from '@material-ui/lab/Autocomplete';
import React, { useCallback, useEffect } from 'react';
import useAsync from 'react-use/esm/useAsync';
export { EntityPickerSchema } from './schema.esm.js';

const EntityPicker = (props) => {
  var _a, _b, _c, _d, _e;
  const {
    onChange,
    schema: { title = "Entity", description = "An entity from the catalog" },
    required,
    uiSchema,
    rawErrors,
    formData,
    idSchema
  } = props;
  const catalogFilter = buildCatalogFilter(uiSchema);
  const defaultKind = (_a = uiSchema["ui:options"]) == null ? void 0 : _a.defaultKind;
  const defaultNamespace = ((_b = uiSchema["ui:options"]) == null ? void 0 : _b.defaultNamespace) || void 0;
  const catalogApi = useApi(catalogApiRef);
  const { value: entities, loading } = useAsync(async () => {
    const fields = ["metadata.name", "metadata.namespace", "kind"];
    const { items } = await catalogApi.getEntities(
      catalogFilter ? { filter: catalogFilter, fields } : { filter: void 0, fields }
    );
    return items;
  });
  const allowArbitraryValues = (_d = (_c = uiSchema["ui:options"]) == null ? void 0 : _c.allowArbitraryValues) != null ? _d : true;
  const getLabel = useCallback(
    (ref) => {
      try {
        return humanizeEntityRef(
          parseEntityRef(ref, { defaultKind, defaultNamespace }),
          {
            defaultKind,
            defaultNamespace
          }
        );
      } catch (err) {
        return ref;
      }
    },
    [defaultKind, defaultNamespace]
  );
  const onSelect = useCallback(
    (_, ref, reason) => {
      if (typeof ref !== "string") {
        onChange(ref ? stringifyEntityRef(ref) : void 0);
      } else {
        if (reason === "blur" || reason === "create-option") {
          let entityRef = ref;
          try {
            entityRef = stringifyEntityRef(
              parseEntityRef(ref, {
                defaultKind,
                defaultNamespace
              })
            );
          } catch (err) {
          }
          if (formData !== ref || allowArbitraryValues) {
            onChange(entityRef);
          }
        }
      }
    },
    [onChange, formData, defaultKind, defaultNamespace, allowArbitraryValues]
  );
  const selectedEntity = (_e = entities == null ? void 0 : entities.find((e) => stringifyEntityRef(e) === formData)) != null ? _e : allowArbitraryValues && formData ? getLabel(formData) : "";
  useEffect(() => {
    if ((entities == null ? void 0 : entities.length) === 1 && selectedEntity === "") {
      onChange(stringifyEntityRef(entities[0]));
    }
  }, [entities, onChange, selectedEntity]);
  return /* @__PURE__ */ React.createElement(
    FormControl,
    {
      margin: "normal",
      required,
      error: (rawErrors == null ? void 0 : rawErrors.length) > 0 && !formData
    },
    /* @__PURE__ */ React.createElement(
      Autocomplete,
      {
        disabled: (entities == null ? void 0 : entities.length) === 1,
        id: idSchema == null ? void 0 : idSchema.$id,
        value: selectedEntity,
        loading,
        onChange: onSelect,
        options: entities || [],
        getOptionLabel: (option) => (
          // option can be a string due to freeSolo.
          typeof option === "string" ? option : humanizeEntityRef(option, { defaultKind, defaultNamespace })
        ),
        autoSelect: true,
        freeSolo: allowArbitraryValues,
        renderInput: (params) => /* @__PURE__ */ React.createElement(
          TextField,
          {
            ...params,
            label: title,
            margin: "dense",
            helperText: description,
            FormHelperTextProps: { margin: "dense", style: { marginLeft: 0 } },
            variant: "outlined",
            required,
            InputProps: params.InputProps
          }
        )
      }
    )
  );
};
function convertOpsValues(value) {
  if (typeof value === "object" && value.exists) {
    return CATALOG_FILTER_EXISTS;
  }
  return value == null ? void 0 : value.toString();
}
function convertSchemaFiltersToQuery(schemaFilters) {
  const query = {};
  for (const [key, value] of Object.entries(schemaFilters)) {
    if (Array.isArray(value)) {
      query[key] = value;
    } else {
      query[key] = convertOpsValues(value);
    }
  }
  return query;
}
function buildCatalogFilter(uiSchema) {
  var _a, _b;
  const allowedKinds = (_a = uiSchema["ui:options"]) == null ? void 0 : _a.allowedKinds;
  const catalogFilter = ((_b = uiSchema["ui:options"]) == null ? void 0 : _b.catalogFilter) || allowedKinds && { kind: allowedKinds };
  if (!catalogFilter) {
    return void 0;
  }
  if (Array.isArray(catalogFilter)) {
    return catalogFilter.map(convertSchemaFiltersToQuery);
  }
  return convertSchemaFiltersToQuery(catalogFilter);
}

export { EntityPicker };
//# sourceMappingURL=EntityPicker.esm.js.map
