import { CATALOG_FILTER_EXISTS } from '@backstage/catalog-client';
import { stringifyEntityRef, parseEntityRef } from '@backstage/catalog-model';
import { useApi } from '@backstage/core-plugin-api';
import { catalogApiRef, entityPresentationApiRef, EntityDisplayName } from '@backstage/plugin-catalog-react';
import TextField from '@material-ui/core/TextField';
import FormControl from '@material-ui/core/FormControl';
import Autocomplete from '@material-ui/lab/Autocomplete';
import React, { useCallback, useEffect } from 'react';
import useAsync from 'react-use/esm/useAsync';
export { MultiEntityPickerSchema } from './schema.esm.js';

const MultiEntityPicker = (props) => {
  var _a, _b, _c, _d, _e;
  const {
    onChange,
    schema: { title = "Entity", description = "An entity from the catalog" },
    required,
    uiSchema,
    rawErrors,
    formData,
    idSchema
  } = props;
  const catalogFilter = buildCatalogFilter(uiSchema);
  const defaultKind = (_a = uiSchema["ui:options"]) == null ? void 0 : _a.defaultKind;
  const defaultNamespace = ((_b = uiSchema["ui:options"]) == null ? void 0 : _b.defaultNamespace) || void 0;
  const catalogApi = useApi(catalogApiRef);
  const entityPresentationApi = useApi(entityPresentationApiRef);
  const { value: entities, loading } = useAsync(async () => {
    const { items } = await catalogApi.getEntities(
      catalogFilter ? { filter: catalogFilter } : void 0
    );
    const entityRefToPresentation = new Map(
      await Promise.all(
        items.map(async (item) => {
          const presentation = await entityPresentationApi.forEntity(item).promise;
          return [stringifyEntityRef(item), presentation];
        })
      )
    );
    return { entities: items, entityRefToPresentation };
  });
  const allowArbitraryValues = (_d = (_c = uiSchema["ui:options"]) == null ? void 0 : _c.allowArbitraryValues) != null ? _d : true;
  const onSelect = useCallback(
    (_, refs, reason) => {
      const values = refs.map((ref) => {
        if (typeof ref !== "string") {
          return ref ? stringifyEntityRef(ref) : void 0;
        }
        if (reason === "blur" || reason === "create-option") {
          let entityRef = ref;
          try {
            entityRef = stringifyEntityRef(
              parseEntityRef(ref, {
                defaultKind,
                defaultNamespace
              })
            );
          } catch (err) {
          }
          if (formData.includes(ref) || allowArbitraryValues) {
            return entityRef;
          }
        }
        return void 0;
      }).filter((ref) => ref !== void 0);
      onChange(values);
    },
    [onChange, formData, defaultKind, defaultNamespace, allowArbitraryValues]
  );
  useEffect(() => {
    var _a2;
    if (((_a2 = entities == null ? void 0 : entities.entities) == null ? void 0 : _a2.length) === 1) {
      onChange([stringifyEntityRef(entities == null ? void 0 : entities.entities[0])]);
    }
  }, [entities, onChange]);
  return /* @__PURE__ */ React.createElement(
    FormControl,
    {
      margin: "normal",
      required,
      error: (rawErrors == null ? void 0 : rawErrors.length) > 0 && !formData
    },
    /* @__PURE__ */ React.createElement(
      Autocomplete,
      {
        multiple: true,
        filterSelectedOptions: true,
        disabled: ((_e = entities == null ? void 0 : entities.entities) == null ? void 0 : _e.length) === 1,
        id: idSchema == null ? void 0 : idSchema.$id,
        loading,
        onChange: onSelect,
        options: (entities == null ? void 0 : entities.entities) || [],
        renderOption: (option) => /* @__PURE__ */ React.createElement(EntityDisplayName, { entityRef: option }),
        getOptionLabel: (option) => {
          var _a2;
          return (
            // option can be a string due to freeSolo.
            typeof option === "string" ? option : (_a2 = entities == null ? void 0 : entities.entityRefToPresentation.get(stringifyEntityRef(option))) == null ? void 0 : _a2.entityRef
          );
        },
        autoSelect: true,
        freeSolo: allowArbitraryValues,
        renderInput: (params) => /* @__PURE__ */ React.createElement(
          TextField,
          {
            ...params,
            label: title,
            margin: "dense",
            helperText: description,
            FormHelperTextProps: {
              margin: "dense",
              style: { marginLeft: 0 }
            },
            variant: "outlined",
            required,
            InputProps: {
              ...params.InputProps,
              required: formData.length === 0 && required
            }
          }
        )
      }
    )
  );
};
const validateMultiEntityPickerValidation = (values, validation) => {
  values.forEach((value) => {
    try {
      parseEntityRef(value);
    } catch {
      validation.addError(`${value} is not a valid entity ref`);
    }
  });
};
function convertOpsValues(value) {
  if (typeof value === "object" && value.exists) {
    return CATALOG_FILTER_EXISTS;
  }
  return value == null ? void 0 : value.toString();
}
function convertSchemaFiltersToQuery(schemaFilters) {
  const query = {};
  for (const [key, value] of Object.entries(schemaFilters)) {
    if (Array.isArray(value)) {
      query[key] = value;
    } else {
      query[key] = convertOpsValues(value);
    }
  }
  return query;
}
function buildCatalogFilter(uiSchema) {
  var _a;
  const catalogFilter = (_a = uiSchema["ui:options"]) == null ? void 0 : _a.catalogFilter;
  if (!catalogFilter) {
    return void 0;
  }
  if (Array.isArray(catalogFilter)) {
    return catalogFilter.map(convertSchemaFiltersToQuery);
  }
  return convertSchemaFiltersToQuery(catalogFilter);
}

export { MultiEntityPicker, validateMultiEntityPickerValidation };
//# sourceMappingURL=MultiEntityPicker.esm.js.map
