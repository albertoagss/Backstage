import { useApi } from '@backstage/core-plugin-api';
import { scmIntegrationsApiRef, scmAuthApiRef } from '@backstage/integration-react';
import React, { useState, useMemo, useEffect, useCallback } from 'react';
import { GithubRepoPicker } from './GithubRepoPicker.esm.js';
import { GiteaRepoPicker } from './GiteaRepoPicker.esm.js';
import { GitlabRepoPicker } from './GitlabRepoPicker.esm.js';
import { AzureRepoPicker } from './AzureRepoPicker.esm.js';
import { BitbucketRepoPicker } from './BitbucketRepoPicker.esm.js';
import { GerritRepoPicker } from './GerritRepoPicker.esm.js';
import { RepoUrlPickerHost } from './RepoUrlPickerHost.esm.js';
import { RepoUrlPickerRepoName } from './RepoUrlPickerRepoName.esm.js';
import { parseRepoPickerUrl, serializeRepoPickerUrl } from './utils.esm.js';
import useDebounce from 'react-use/esm/useDebounce';
import { useTemplateSecrets } from '@backstage/plugin-scaffolder-react';
import Box from '@material-ui/core/Box';
import Divider from '@material-ui/core/Divider';
import Typography from '@material-ui/core/Typography';
export { RepoUrlPickerSchema } from './schema.esm.js';

const RepoUrlPicker = (props) => {
  var _a, _b;
  const { uiSchema, onChange, rawErrors, formData, schema } = props;
  const [state, setState] = useState(
    parseRepoPickerUrl(formData)
  );
  const integrationApi = useApi(scmIntegrationsApiRef);
  const scmAuthApi = useApi(scmAuthApiRef);
  const { secrets, setSecrets } = useTemplateSecrets();
  const allowedHosts = useMemo(
    () => {
      var _a2, _b2;
      return (_b2 = (_a2 = uiSchema == null ? void 0 : uiSchema["ui:options"]) == null ? void 0 : _a2.allowedHosts) != null ? _b2 : [];
    },
    [uiSchema]
  );
  const allowedOrganizations = useMemo(
    () => {
      var _a2, _b2;
      return (_b2 = (_a2 = uiSchema == null ? void 0 : uiSchema["ui:options"]) == null ? void 0 : _a2.allowedOrganizations) != null ? _b2 : [];
    },
    [uiSchema]
  );
  const allowedOwners = useMemo(
    () => {
      var _a2, _b2;
      return (_b2 = (_a2 = uiSchema == null ? void 0 : uiSchema["ui:options"]) == null ? void 0 : _a2.allowedOwners) != null ? _b2 : [];
    },
    [uiSchema]
  );
  const allowedProjects = useMemo(
    () => {
      var _a2, _b2;
      return (_b2 = (_a2 = uiSchema == null ? void 0 : uiSchema["ui:options"]) == null ? void 0 : _a2.allowedProjects) != null ? _b2 : [];
    },
    [uiSchema]
  );
  const allowedRepos = useMemo(
    () => {
      var _a2, _b2;
      return (_b2 = (_a2 = uiSchema == null ? void 0 : uiSchema["ui:options"]) == null ? void 0 : _a2.allowedRepos) != null ? _b2 : [];
    },
    [uiSchema]
  );
  const { owner, organization, project, repoName } = state;
  useEffect(() => {
    onChange(serializeRepoPickerUrl(state));
  }, [state, onChange]);
  useEffect(() => {
    if (allowedOrganizations.length > 0 && !organization) {
      setState((prevState) => ({
        ...prevState,
        organization: allowedOrganizations[0]
      }));
    }
  }, [setState, allowedOrganizations, organization]);
  useEffect(() => {
    if (allowedOwners.length > 0 && !owner) {
      setState((prevState) => ({
        ...prevState,
        owner: allowedOwners[0]
      }));
    }
  }, [setState, allowedOwners, owner]);
  useEffect(() => {
    if (allowedProjects.length > 0 && !project) {
      setState((prevState) => ({
        ...prevState,
        project: allowedProjects[0]
      }));
    }
  }, [setState, allowedProjects, project]);
  useEffect(() => {
    if (allowedRepos.length > 0 && !repoName) {
      setState((prevState) => ({ ...prevState, repoName: allowedRepos[0] }));
    }
  }, [setState, allowedRepos, repoName]);
  const updateLocalState = useCallback(
    (newState) => {
      setState((prevState) => ({ ...prevState, ...newState }));
    },
    [setState]
  );
  useDebounce(
    async () => {
      var _a2;
      const { requestUserCredentials } = (_a2 = uiSchema == null ? void 0 : uiSchema["ui:options"]) != null ? _a2 : {};
      const workspace = state.owner ? state.owner : state.project;
      if (!requestUserCredentials || !(state.host && workspace && state.repoName)) {
        return;
      }
      if (secrets[requestUserCredentials.secretsKey]) {
        return;
      }
      const [encodedHost, encodedRepoName] = [state.host, state.repoName].map(
        encodeURIComponent
      );
      const { token } = await scmAuthApi.getCredentials({
        url: `https://${encodedHost}/${workspace}/${encodedRepoName}`,
        additionalScope: {
          repoWrite: true,
          customScopes: requestUserCredentials.additionalScopes
        }
      });
      setSecrets({ [requestUserCredentials.secretsKey]: token });
    },
    500,
    [state, uiSchema]
  );
  const hostType = (_b = state.host && ((_a = integrationApi.byHost(state.host)) == null ? void 0 : _a.type)) != null ? _b : null;
  return /* @__PURE__ */ React.createElement(React.Fragment, null, schema.title && /* @__PURE__ */ React.createElement(Box, { my: 1 }, /* @__PURE__ */ React.createElement(Typography, { variant: "h5" }, schema.title), /* @__PURE__ */ React.createElement(Divider, null)), schema.description && /* @__PURE__ */ React.createElement(Typography, { variant: "body1" }, schema.description), /* @__PURE__ */ React.createElement(
    RepoUrlPickerHost,
    {
      host: state.host,
      hosts: allowedHosts,
      onChange: (host) => setState((prevState) => ({ ...prevState, host })),
      rawErrors
    }
  ), hostType === "github" && /* @__PURE__ */ React.createElement(
    GithubRepoPicker,
    {
      allowedOwners,
      onChange: updateLocalState,
      rawErrors,
      state
    }
  ), hostType === "gitea" && /* @__PURE__ */ React.createElement(
    GiteaRepoPicker,
    {
      allowedOwners,
      allowedRepos,
      rawErrors,
      state,
      onChange: updateLocalState
    }
  ), hostType === "gitlab" && /* @__PURE__ */ React.createElement(
    GitlabRepoPicker,
    {
      allowedOwners,
      rawErrors,
      state,
      onChange: updateLocalState
    }
  ), hostType === "bitbucket" && /* @__PURE__ */ React.createElement(
    BitbucketRepoPicker,
    {
      allowedOwners,
      allowedProjects,
      rawErrors,
      state,
      onChange: updateLocalState
    }
  ), hostType === "azure" && /* @__PURE__ */ React.createElement(
    AzureRepoPicker,
    {
      allowedOrganizations,
      allowedOwners,
      rawErrors,
      state,
      onChange: updateLocalState
    }
  ), hostType === "gerrit" && /* @__PURE__ */ React.createElement(
    GerritRepoPicker,
    {
      rawErrors,
      state,
      onChange: updateLocalState
    }
  ), /* @__PURE__ */ React.createElement(
    RepoUrlPickerRepoName,
    {
      repoName: state.repoName,
      allowedRepos,
      onChange: (repo) => setState((prevState) => ({ ...prevState, repoName: repo })),
      rawErrors
    }
  ));
};

export { RepoUrlPicker };
//# sourceMappingURL=RepoUrlPicker.esm.js.map
