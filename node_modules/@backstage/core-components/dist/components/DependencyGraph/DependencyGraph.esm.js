import React from 'react';
import * as d3Zoom from 'd3-zoom';
import * as d3Selection from 'd3-selection';
import useTheme from '@material-ui/core/styles/useTheme';
import dagre from 'dagre';
import debounce from 'lodash/debounce';
import { DependencyGraphTypes } from './types.esm.js';
import { Node } from './Node.esm.js';
import { Edge } from './Edge.esm.js';
import { ARROW_MARKER_ID } from './constants.esm.js';

const WORKSPACE_ID = "workspace";
function DependencyGraph(props) {
  var _a, _b;
  const {
    edges,
    nodes,
    renderNode,
    direction = DependencyGraphTypes.Direction.TOP_BOTTOM,
    align,
    nodeMargin = 50,
    edgeMargin = 10,
    rankMargin = 50,
    paddingX = 0,
    paddingY = 0,
    acyclicer,
    ranker = DependencyGraphTypes.Ranker.NETWORK_SIMPLEX,
    labelPosition = DependencyGraphTypes.LabelPosition.RIGHT,
    labelOffset = 10,
    edgeRanks = 1,
    edgeWeight = 1,
    renderLabel,
    defs,
    zoom = "enabled",
    curve = "curveMonotoneX",
    showArrowHeads = false,
    fit = "grow",
    ...svgProps
  } = props;
  const theme = useTheme();
  const [containerWidth, setContainerWidth] = React.useState(100);
  const [containerHeight, setContainerHeight] = React.useState(100);
  const graph = React.useRef(new dagre.graphlib.Graph());
  const [graphWidth, setGraphWidth] = React.useState(
    ((_a = graph.current.graph()) == null ? void 0 : _a.width) || 0
  );
  const [graphHeight, setGraphHeight] = React.useState(
    ((_b = graph.current.graph()) == null ? void 0 : _b.height) || 0
  );
  const [graphNodes, setGraphNodes] = React.useState([]);
  const [graphEdges, setGraphEdges] = React.useState([]);
  const maxWidth = Math.max(graphWidth, containerWidth);
  const maxHeight = Math.max(graphHeight, containerHeight);
  const minHeight = Math.min(graphHeight, containerHeight);
  const scalableHeight = fit === "grow" ? maxHeight : minHeight;
  const containerRef = React.useMemo(
    () => debounce((node) => {
      if (!node) {
        return;
      }
      const container = d3Selection.select(node);
      const workspace = d3Selection.select(node.getElementById(WORKSPACE_ID));
      function enableZoom() {
        container.call(
          d3Zoom.zoom().scaleExtent([1, Infinity]).on("zoom", (event) => {
            event.transform.x = Math.min(
              0,
              Math.max(
                event.transform.x,
                maxWidth - maxWidth * event.transform.k
              )
            );
            event.transform.y = Math.min(
              0,
              Math.max(
                event.transform.y,
                maxHeight - maxHeight * event.transform.k
              )
            );
            workspace.attr("transform", event.transform);
          })
        );
      }
      if (zoom === "enabled") {
        enableZoom();
      } else if (zoom === "enable-on-click") {
        container.on("click", () => enableZoom());
      }
      const { width: newContainerWidth, height: newContainerHeight } = node.getBoundingClientRect();
      if (containerWidth !== newContainerWidth) {
        setContainerWidth(newContainerWidth);
      }
      if (containerHeight !== newContainerHeight) {
        setContainerHeight(newContainerHeight);
      }
    }, 100),
    [containerHeight, containerWidth, maxWidth, maxHeight, zoom]
  );
  const setNodesAndEdges = React.useCallback(() => {
    const currentGraphNodes = graph.current.nodes();
    const currentGraphEdges = graph.current.edges();
    currentGraphNodes.forEach((nodeId) => {
      const remainingNode = nodes.some((node) => node.id === nodeId);
      if (!remainingNode) {
        graph.current.removeNode(nodeId);
      }
    });
    currentGraphEdges.forEach((e) => {
      const remainingEdge = edges.some(
        (edge) => edge.from === e.v && edge.to === e.w
      );
      if (!remainingEdge) {
        graph.current.removeEdge(e.v, e.w);
      }
    });
    nodes.forEach((node) => {
      const existingNode = graph.current.nodes().find((nodeId) => node.id === nodeId);
      if (existingNode && graph.current.node(existingNode)) {
        const { width, height, x, y } = graph.current.node(existingNode);
        graph.current.setNode(existingNode, { ...node, width, height, x, y });
      } else {
        graph.current.setNode(node.id, { ...node, width: 0, height: 0 });
      }
    });
    edges.forEach((e) => {
      graph.current.setEdge(e.from, e.to, {
        ...e,
        label: e.label,
        width: 0,
        height: 0,
        labelpos: labelPosition,
        labeloffset: labelOffset,
        weight: edgeWeight,
        minlen: edgeRanks
      });
    });
  }, [edges, nodes, labelPosition, labelOffset, edgeWeight, edgeRanks]);
  const updateGraph = React.useMemo(
    () => debounce(
      () => {
        dagre.layout(graph.current);
        const { height, width } = graph.current.graph();
        const newHeight = Math.max(0, height || 0);
        const newWidth = Math.max(0, width || 0);
        setGraphWidth(newWidth);
        setGraphHeight(newHeight);
        setGraphNodes(graph.current.nodes());
        setGraphEdges(graph.current.edges());
      },
      250,
      { leading: true }
    ),
    []
  );
  React.useEffect(() => {
    graph.current.setGraph({
      rankdir: direction,
      align,
      nodesep: nodeMargin,
      edgesep: edgeMargin,
      ranksep: rankMargin,
      marginx: paddingX,
      marginy: paddingY,
      acyclicer,
      ranker
    });
    setNodesAndEdges();
    updateGraph();
    return updateGraph.cancel;
  }, [
    acyclicer,
    align,
    direction,
    edgeMargin,
    paddingX,
    paddingY,
    nodeMargin,
    rankMargin,
    ranker,
    setNodesAndEdges,
    updateGraph
  ]);
  function setNode(id, node) {
    graph.current.setNode(id, node);
    updateGraph();
    return graph.current;
  }
  function setEdge(id, edge) {
    graph.current.setEdge(id, edge);
    updateGraph();
    return graph.current;
  }
  return /* @__PURE__ */ React.createElement(
    "svg",
    {
      ref: containerRef,
      ...svgProps,
      width: "100%",
      height: scalableHeight,
      viewBox: `0 0 ${maxWidth} ${maxHeight}`
    },
    /* @__PURE__ */ React.createElement("defs", null, /* @__PURE__ */ React.createElement(
      "marker",
      {
        id: ARROW_MARKER_ID,
        viewBox: "0 0 24 24",
        markerWidth: "14",
        markerHeight: "14",
        refX: "16",
        refY: "12",
        orient: "auto",
        markerUnits: "strokeWidth"
      },
      /* @__PURE__ */ React.createElement(
        "path",
        {
          fill: theme.palette.textSubtle,
          d: "M8.59 16.59L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.41z"
        }
      )
    ), defs),
    /* @__PURE__ */ React.createElement("g", { id: WORKSPACE_ID }, /* @__PURE__ */ React.createElement(
      "svg",
      {
        width: graphWidth,
        height: graphHeight,
        y: maxHeight / 2 - graphHeight / 2,
        x: maxWidth / 2 - graphWidth / 2,
        viewBox: `0 0 ${graphWidth} ${graphHeight}`
      },
      graphEdges.map((e) => {
        const edge = graph.current.edge(e);
        if (!edge)
          return null;
        return /* @__PURE__ */ React.createElement(
          Edge,
          {
            key: `${e.v}-${e.w}`,
            id: e,
            setEdge,
            render: renderLabel,
            edge,
            curve,
            showArrowHeads
          }
        );
      }),
      graphNodes.map((id) => {
        const node = graph.current.node(id);
        if (!node)
          return null;
        return /* @__PURE__ */ React.createElement(
          Node,
          {
            key: id,
            setNode,
            render: renderNode,
            node
          }
        );
      })
    ))
  );
}

export { DependencyGraph };
//# sourceMappingURL=DependencyGraph.esm.js.map
