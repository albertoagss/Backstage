import ansiRegexMaker from 'ansi-regex';

var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
const ansiRegex = ansiRegexMaker();
const newlineRegex = /\n\r?/g;
const codeModifiers = Object.fromEntries(
  Object.entries({
    1: (m) => ({ ...m, bold: true }),
    3: (m) => ({ ...m, italic: true }),
    4: (m) => ({ ...m, underline: true }),
    22: ({ bold: _, ...m }) => m,
    23: ({ italic: _, ...m }) => m,
    24: ({ underline: _, ...m }) => m,
    30: (m) => ({ ...m, foreground: "black" }),
    31: (m) => ({ ...m, foreground: "red" }),
    32: (m) => ({ ...m, foreground: "green" }),
    33: (m) => ({ ...m, foreground: "yellow" }),
    34: (m) => ({ ...m, foreground: "blue" }),
    35: (m) => ({ ...m, foreground: "magenta" }),
    36: (m) => ({ ...m, foreground: "cyan" }),
    37: (m) => ({ ...m, foreground: "white" }),
    39: ({ foreground: _, ...m }) => m,
    90: (m) => ({ ...m, foreground: "grey" }),
    40: (m) => ({ ...m, background: "black" }),
    41: (m) => ({ ...m, background: "red" }),
    42: (m) => ({ ...m, background: "green" }),
    43: (m) => ({ ...m, background: "yellow" }),
    44: (m) => ({ ...m, background: "blue" }),
    45: (m) => ({ ...m, background: "magenta" }),
    46: (m) => ({ ...m, background: "cyan" }),
    47: (m) => ({ ...m, background: "white" }),
    49: ({ background: _, ...m }) => m
  }).map(
    ([code, modifier]) => [`\x1B[${code}m`, modifier]
  )
);
class AnsiLine {
  constructor(lineNumber = 1, chunks = []) {
    this.lineNumber = lineNumber;
    this.chunks = chunks;
    __publicField(this, "text");
    this.text = chunks.map((c) => c.text).join("").toLocaleLowerCase("en-US");
  }
  lastChunk() {
    return this.chunks[this.chunks.length - 1];
  }
  replaceLastChunk(newChunks) {
    if (newChunks) {
      this.chunks.splice(this.chunks.length - 1, 1, ...newChunks);
      this.text = this.chunks.map((c) => c.text).join("").toLocaleLowerCase("en-US");
    }
  }
}
class AnsiProcessor {
  constructor() {
    __publicField(this, "text", "");
    __publicField(this, "lines", []);
    // Split a chunk of text up into lines and process each line individually
    __publicField(this, "processLines", (text, modifiers = {}, startingLineNumber = 1) => {
      var _a;
      const lines = [];
      let currentModifiers = modifiers;
      let currentLineNumber = startingLineNumber;
      let prevIndex = 0;
      newlineRegex.lastIndex = 0;
      for (; ; ) {
        const match = newlineRegex.exec(text);
        if (!match) {
          const chunks2 = this.processText(
            text.slice(prevIndex),
            currentModifiers
          );
          lines.push(new AnsiLine(currentLineNumber, chunks2));
          return lines;
        }
        const line = text.slice(prevIndex, match.index);
        prevIndex = match.index + match[0].length;
        const chunks = this.processText(line, currentModifiers);
        lines.push(new AnsiLine(currentLineNumber, chunks));
        currentModifiers = (_a = chunks[chunks.length - 1].modifiers) != null ? _a : currentModifiers;
        currentLineNumber += 1;
      }
    });
    // Processing of a one individual text chunk
    __publicField(this, "processText", (fullText, modifiers) => {
      const chunks = [];
      let currentModifiers = modifiers;
      let prevIndex = 0;
      ansiRegex.lastIndex = 0;
      for (; ; ) {
        const match = ansiRegex.exec(fullText);
        if (!match) {
          chunks.push({
            text: fullText.slice(prevIndex),
            modifiers: currentModifiers
          });
          return chunks;
        }
        const text = fullText.slice(prevIndex, match.index);
        chunks.push({ text, modifiers: currentModifiers });
        prevIndex = match.index + match[0].length;
        currentModifiers = this.processCode(match[0], currentModifiers);
      }
    });
    __publicField(this, "processCode", (code, modifiers) => {
      var _a, _b;
      return (_b = (_a = codeModifiers[code]) == null ? void 0 : _a.call(codeModifiers, modifiers)) != null ? _b : modifiers;
    });
  }
  /**
   * Processes a chunk of text while keeping internal state that optimizes
   * subsequent processing that appends to the text.
   */
  process(text) {
    var _a, _b, _c;
    if (this.text === text) {
      return this.lines;
    }
    if (this.text && text.startsWith(this.text)) {
      const lastLineIndex = this.lines.length > 0 ? this.lines.length - 1 : 0;
      const lastLine = (_a = this.lines[lastLineIndex]) != null ? _a : new AnsiLine();
      const lastChunk = lastLine.lastChunk();
      const newLines = this.processLines(
        ((_b = lastChunk == null ? void 0 : lastChunk.text) != null ? _b : "") + text.slice(this.text.length),
        lastChunk == null ? void 0 : lastChunk.modifiers,
        lastLine == null ? void 0 : lastLine.lineNumber
      );
      lastLine.replaceLastChunk((_c = newLines[0]) == null ? void 0 : _c.chunks);
      this.lines[lastLineIndex] = lastLine;
      this.lines = this.lines.concat(newLines.slice(1));
    } else {
      this.lines = this.processLines(text);
    }
    this.text = text;
    return this.lines;
  }
}

export { AnsiLine, AnsiProcessor };
//# sourceMappingURL=AnsiProcessor.esm.js.map
