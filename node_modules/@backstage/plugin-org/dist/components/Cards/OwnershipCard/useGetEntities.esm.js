import { parseEntityRef, stringifyEntityRef, RELATION_MEMBER_OF, RELATION_PARENT_OF } from '@backstage/catalog-model';
import { catalogApiRef, humanizeEntityRef, getEntityRelations } from '@backstage/plugin-catalog-react';
import limiterFactory from 'p-limit';
import { useApi } from '@backstage/core-plugin-api';
import useAsync from 'react-use/esm/useAsync';
import qs from 'qs';
import { uniq } from 'lodash';

const limiter = limiterFactory(5);
const getQueryParams = (ownersEntityRef, selectedEntity) => {
  const { kind, type } = selectedEntity;
  const owners = ownersEntityRef.map(
    (owner) => humanizeEntityRef(parseEntityRef(owner), { defaultKind: "group" })
  );
  const filters = {
    kind: kind.toLocaleLowerCase("en-US"),
    type,
    owners,
    user: "all"
  };
  return qs.stringify({ filters }, { arrayFormat: "repeat" });
};
const getMemberOfEntityRefs = (owner) => {
  const parentGroups = getEntityRelations(owner, RELATION_MEMBER_OF, {
    kind: "Group"
  });
  const ownerGroupsNames = parentGroups.map(
    ({ kind, namespace, name }) => stringifyEntityRef({
      kind,
      namespace,
      name
    })
  );
  return [...ownerGroupsNames, stringifyEntityRef(owner)];
};
const isEntity = (entity) => entity !== void 0;
const getChildOwnershipEntityRefs = async (entity, catalogApi, alreadyRetrievedParentRefs = []) => {
  const childGroups = getEntityRelations(entity, RELATION_PARENT_OF, {
    kind: "Group"
  });
  const hasChildGroups = childGroups.length > 0;
  const entityRef = stringifyEntityRef(entity);
  if (hasChildGroups) {
    const entityRefs = childGroups.map((r) => stringifyEntityRef(r));
    const childGroupResponse = await limiter(
      () => catalogApi.getEntitiesByRefs({
        fields: ["kind", "metadata.namespace", "metadata.name", "relations"],
        entityRefs
      })
    );
    const childGroupEntities = childGroupResponse.items.filter(isEntity);
    const unknownChildren = childGroupEntities.filter(
      (childGroupEntity) => !alreadyRetrievedParentRefs.includes(
        stringifyEntityRef(childGroupEntity)
      )
    );
    const childrenRefs = (await Promise.all(
      unknownChildren.map(
        (childGroupEntity) => getChildOwnershipEntityRefs(childGroupEntity, catalogApi, [
          ...alreadyRetrievedParentRefs,
          entityRef
        ])
      )
    )).flatMap((aggregated) => aggregated);
    return uniq([...childrenRefs, entityRef]);
  }
  return [entityRef];
};
const getOwners = async (entity, relations, catalogApi) => {
  const isGroup = entity.kind === "Group";
  const isAggregated = relations === "aggregated";
  const isUserEntity = entity.kind === "User";
  if (isAggregated && isGroup) {
    return getChildOwnershipEntityRefs(entity, catalogApi);
  }
  if (isAggregated && isUserEntity) {
    return getMemberOfEntityRefs(entity);
  }
  return [stringifyEntityRef(entity)];
};
const getOwnedEntitiesByOwners = (owners, kinds, catalogApi) => catalogApi.getEntities({
  filter: [
    {
      kind: kinds,
      "relations.ownedBy": owners
    }
  ],
  fields: [
    "kind",
    "metadata.name",
    "metadata.namespace",
    "spec.type",
    "relations"
  ]
});
function useGetEntities(entity, relations, entityFilterKind, entityLimit = 6) {
  const catalogApi = useApi(catalogApiRef);
  const kinds = entityFilterKind != null ? entityFilterKind : ["Component", "API", "System"];
  const {
    loading,
    error,
    value: componentsWithCounters
  } = useAsync(async () => {
    const owners = await getOwners(entity, relations, catalogApi);
    const ownedEntitiesList = await getOwnedEntitiesByOwners(
      owners,
      kinds,
      catalogApi
    );
    const counts = ownedEntitiesList.items.reduce(
      (acc, ownedEntity) => {
        var _a, _b;
        const match = acc.find(
          (x) => {
            var _a2;
            return x.kind === ownedEntity.kind && x.type === ((_a2 = ownedEntity.spec) == null ? void 0 : _a2.type);
          }
        );
        if (match) {
          match.count += 1;
        } else {
          acc.push({
            kind: ownedEntity.kind,
            type: (_b = (_a = ownedEntity.spec) == null ? void 0 : _a.type) == null ? void 0 : _b.toString(),
            count: 1
          });
        }
        return acc;
      },
      []
    );
    const topN = counts.sort((a, b) => b.count - a.count).slice(0, entityLimit);
    return topN.map((topOwnedEntity) => ({
      counter: topOwnedEntity.count,
      type: topOwnedEntity.type,
      kind: topOwnedEntity.kind,
      queryParams: getQueryParams(owners, topOwnedEntity)
    }));
  }, [catalogApi, entity, relations]);
  return {
    componentsWithCounters,
    loading,
    error
  };
}

export { useGetEntities };
//# sourceMappingURL=useGetEntities.esm.js.map
