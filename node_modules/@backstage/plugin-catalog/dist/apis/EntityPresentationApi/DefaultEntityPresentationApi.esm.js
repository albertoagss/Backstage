import { stringifyEntityRef, parseEntityRef } from '@backstage/catalog-model';
import { durationToMilliseconds } from '@backstage/types';
import DataLoader from 'dataloader';
import ExpiryMap from 'expiry-map';
import ObservableImpl from 'zen-observable';
import { DEFAULT_CACHE_TTL, DEFAULT_BATCH_DELAY, createDefaultRenderer, DEFAULT_ICONS } from './defaults.esm.js';

var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  member.set(obj, value);
  return value;
};
var __privateMethod = (obj, member, method) => {
  __accessCheck(obj, member, "access private method");
  return method;
};
var _cache, _cacheTtlMs, _loader, _kindIcons, _renderer, _getEntityForInitialRender, getEntityForInitialRender_fn, _createLoader, createLoader_fn, _maybeFallbackIcon, maybeFallbackIcon_fn;
const _DefaultEntityPresentationApi = class _DefaultEntityPresentationApi {
  constructor(options) {
    __privateAdd(this, _getEntityForInitialRender);
    __privateAdd(this, _createLoader);
    __privateAdd(this, _maybeFallbackIcon);
    // This cache holds on to all entity data ever loaded, no matter how old. Each
    // entry is tagged with a timestamp of when it was inserted. We use this map
    // to be able to always render SOME data even though the information is old.
    // Entities change very rarely, so it's likely that the rendered information
    // was perfectly fine in the first place.
    __privateAdd(this, _cache, void 0);
    __privateAdd(this, _cacheTtlMs, void 0);
    __privateAdd(this, _loader, void 0);
    __privateAdd(this, _kindIcons, void 0);
    // lowercased kinds
    __privateAdd(this, _renderer, void 0);
    var _a, _b, _c, _d;
    const cacheTtl = (_a = options.cacheTtl) != null ? _a : DEFAULT_CACHE_TTL;
    const batchDelay = (_b = options.batchDelay) != null ? _b : DEFAULT_BATCH_DELAY;
    const renderer = (_c = options.renderer) != null ? _c : createDefaultRenderer({ async: true });
    const kindIcons = {};
    Object.entries(DEFAULT_ICONS).forEach(([kind, icon]) => {
      kindIcons[kind.toLocaleLowerCase("en-US")] = icon;
    });
    Object.entries((_d = options.kindIcons) != null ? _d : {}).forEach(([kind, icon]) => {
      kindIcons[kind.toLocaleLowerCase("en-US")] = icon;
    });
    if (renderer.async) {
      if (!options.catalogApi) {
        throw new TypeError(`Asynchronous rendering requires a catalog API`);
      }
      __privateSet(this, _loader, __privateMethod(this, _createLoader, createLoader_fn).call(this, {
        cacheTtl,
        batchDelay,
        renderer,
        catalogApi: options.catalogApi
      }));
    }
    __privateSet(this, _cacheTtlMs, durationToMilliseconds(cacheTtl));
    __privateSet(this, _cache, /* @__PURE__ */ new Map());
    __privateSet(this, _kindIcons, kindIcons);
    __privateSet(this, _renderer, renderer);
  }
  /**
   * Creates a new presentation API that does not reach out to the catalog.
   */
  static createLocal() {
    return new _DefaultEntityPresentationApi({
      renderer: createDefaultRenderer({ async: false })
    });
  }
  /**
   * Creates a new presentation API that calls out to the catalog as needed to
   * get additional information about entities.
   */
  static create(options) {
    return new _DefaultEntityPresentationApi(options);
  }
  /** {@inheritdoc @backstage/plugin-catalog-react#EntityPresentationApi.forEntity} */
  forEntity(entityOrRef, context) {
    const { entityRef, kind, entity, needsLoad } = __privateMethod(this, _getEntityForInitialRender, getEntityForInitialRender_fn).call(this, entityOrRef);
    const render = (options) => {
      const { snapshot } = __privateGet(this, _renderer).render({
        entityRef,
        loading: options.loading,
        entity: options.entity,
        context: context || {}
      });
      return {
        ...snapshot,
        entityRef,
        Icon: __privateMethod(this, _maybeFallbackIcon, maybeFallbackIcon_fn).call(this, snapshot.Icon, kind)
      };
    };
    let initialSnapshot;
    try {
      initialSnapshot = render({
        loading: needsLoad,
        entity
      });
    } catch {
      initialSnapshot = {
        primaryTitle: entityRef,
        entityRef
      };
    }
    if (!needsLoad) {
      return {
        snapshot: initialSnapshot,
        promise: Promise.resolve(initialSnapshot)
      };
    }
    const maybeUpdatedSnapshot = Promise.resolve().then(() => {
      var _a;
      return (_a = __privateGet(this, _loader)) == null ? void 0 : _a.load(entityRef);
    }).then((newEntity) => {
      return render({
        loading: false,
        entity: newEntity != null ? newEntity : entity
      });
    }).catch(() => {
      return void 0;
    });
    const observable = new ObservableImpl(
      (subscriber) => {
        let aborted = false;
        maybeUpdatedSnapshot.then((updatedSnapshot) => {
          if (updatedSnapshot) {
            subscriber.next(updatedSnapshot);
          }
        }).finally(() => {
          if (!aborted) {
            subscriber.complete();
          }
        });
        return () => {
          aborted = true;
        };
      }
    );
    const promise = maybeUpdatedSnapshot.then((updatedSnapshot) => {
      return updatedSnapshot != null ? updatedSnapshot : initialSnapshot;
    });
    return {
      snapshot: initialSnapshot,
      update$: observable,
      promise
    };
  }
};
_cache = new WeakMap();
_cacheTtlMs = new WeakMap();
_loader = new WeakMap();
_kindIcons = new WeakMap();
_renderer = new WeakMap();
_getEntityForInitialRender = new WeakSet();
getEntityForInitialRender_fn = function(entityOrRef) {
  if (typeof entityOrRef !== "string") {
    return {
      entity: entityOrRef,
      kind: entityOrRef.kind,
      entityRef: stringifyEntityRef(entityOrRef),
      needsLoad: false
    };
  }
  const cached = __privateGet(this, _cache).get(entityOrRef);
  const cachedEntity = cached == null ? void 0 : cached.entity;
  const cacheNeedsUpdate = !cached || Date.now() - cached.updatedAt > __privateGet(this, _cacheTtlMs);
  const needsLoad = cacheNeedsUpdate && __privateGet(this, _renderer).async !== false && __privateGet(this, _loader) !== void 0;
  return {
    entity: cachedEntity,
    kind: parseEntityRef(entityOrRef).kind,
    entityRef: entityOrRef,
    needsLoad
  };
};
_createLoader = new WeakSet();
createLoader_fn = function(options) {
  const cacheTtlMs = durationToMilliseconds(options.cacheTtl);
  const batchDelayMs = durationToMilliseconds(options.batchDelay);
  return new DataLoader(
    async (entityRefs) => {
      const { items } = await options.catalogApi.getEntitiesByRefs({
        entityRefs
      });
      const now = Date.now();
      entityRefs.forEach((entityRef, index) => {
        __privateGet(this, _cache).set(entityRef, {
          updatedAt: now,
          entity: items[index]
        });
      });
      return items;
    },
    {
      name: "DefaultEntityPresentationApi",
      // This cache is the one that the data loader uses internally for
      // memoizing requests; essentially what it achieves is that multiple
      // requests for the same entity ref will be batched up into a single
      // request and then the resulting promises are held on to. We put an
      // expiring map here, which makes it so that it re-fetches data with the
      // expiry cadence of that map. Otherwise it would only fetch a given ref
      // once and then never try again. This cache does therefore not fulfill
      // the same purpose as the one that is in the root of the class.
      cacheMap: new ExpiryMap(cacheTtlMs),
      maxBatchSize: 100,
      batchScheduleFn: batchDelayMs ? (cb) => setTimeout(cb, batchDelayMs) : void 0
    }
  );
};
_maybeFallbackIcon = new WeakSet();
maybeFallbackIcon_fn = function(renderedIcon, kind) {
  if (renderedIcon) {
    return renderedIcon;
  } else if (renderedIcon === false) {
    return false;
  }
  return __privateGet(this, _kindIcons)[kind.toLocaleLowerCase("en-US")];
};
let DefaultEntityPresentationApi = _DefaultEntityPresentationApi;

export { DefaultEntityPresentationApi };
//# sourceMappingURL=DefaultEntityPresentationApi.esm.js.map
