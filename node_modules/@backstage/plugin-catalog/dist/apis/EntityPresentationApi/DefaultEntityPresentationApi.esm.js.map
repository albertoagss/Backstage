{"version":3,"file":"DefaultEntityPresentationApi.esm.js","sources":["../../../src/apis/EntityPresentationApi/DefaultEntityPresentationApi.ts"],"sourcesContent":["/*\n * Copyright 2023 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  Entity,\n  parseEntityRef,\n  stringifyEntityRef,\n} from '@backstage/catalog-model';\nimport { IconComponent } from '@backstage/core-plugin-api';\nimport {\n  CatalogApi,\n  EntityPresentationApi,\n  EntityRefPresentation,\n  EntityRefPresentationSnapshot,\n} from '@backstage/plugin-catalog-react';\nimport { HumanDuration, durationToMilliseconds } from '@backstage/types';\nimport DataLoader from 'dataloader';\nimport ExpiryMap from 'expiry-map';\nimport ObservableImpl from 'zen-observable';\nimport {\n  DEFAULT_BATCH_DELAY,\n  DEFAULT_CACHE_TTL,\n  DEFAULT_ICONS,\n  createDefaultRenderer,\n} from './defaults';\n\n/**\n * A custom renderer for the {@link DefaultEntityPresentationApi}.\n *\n * @public\n */\nexport interface DefaultEntityPresentationApiRenderer {\n  /**\n   * Whether to request the entity from the catalog API asynchronously.\n   *\n   * @remarks\n   *\n   * If this is set to true, entity data will be streamed in from the catalog\n   * whenever needed, and the render function may be called more than once:\n   * first when no entity data existed (or with old cached data), and then again\n   * at a later point when data is loaded from the catalog that proved to be\n   * different from the old one.\n   *\n   * @defaultValue true\n   */\n  async?: boolean;\n\n  /**\n   * The actual render function.\n   *\n   * @remarks\n   *\n   * This function may be called multiple times.\n   *\n   * The loading flag signals that the framework MAY be trying to load more\n   * entity data from the catalog and call the render function again, if it\n   * succeeds. In some cases you may want to render a loading state in that\n   * case.\n   *\n   * The entity may or may not be given. If the caller of the presentation API\n   * did present an entity upfront, then that's what will be passed in here.\n   * Otherwise, it may be a server-side entity that either comes from a local\n   * cache or directly from the server.\n   *\n   * In either case, the renderer should return a presentation that is the most\n   * useful possible for the end user, given the data that is available.\n   */\n  render: (options: {\n    entityRef: string;\n    loading: boolean;\n    entity: Entity | undefined;\n    context: {\n      defaultKind?: string;\n      defaultNamespace?: string;\n    };\n  }) => {\n    snapshot: Omit<EntityRefPresentationSnapshot, 'entityRef'>;\n  };\n}\n\n/**\n * Options for the {@link DefaultEntityPresentationApi}.\n *\n * @public\n */\nexport interface DefaultEntityPresentationApiOptions {\n  /**\n   * The catalog API to use. If you want to use any asynchronous features, you\n   * must supply one.\n   */\n  catalogApi?: CatalogApi;\n\n  /**\n   * When to expire entities that have been loaded from the catalog API and\n   * cached for a while.\n   *\n   * @defaultValue 10 seconds\n   * @remarks\n   *\n   * The higher this value, the lower the load on the catalog API, but also the\n   * higher the risk of users seeing stale data.\n   */\n  cacheTtl?: HumanDuration;\n\n  /**\n   * For how long to wait before sending a batch of entity references to the\n   * catalog API.\n   *\n   * @defaultValue 50 milliseconds\n   * @remarks\n   *\n   * The higher this value, the greater the chance of batching up requests from\n   * across a page, but also the longer the lag time before displaying accurate\n   * information.\n   */\n  batchDelay?: HumanDuration;\n\n  /**\n   * A mapping from kinds to icons.\n   *\n   * @remarks\n   *\n   * The keys are kinds (case insensitive) that map to icon values to represent\n   * kinds by. These are merged with the default set of icons.\n   */\n  kindIcons?: Record<string, IconComponent>;\n\n  /**\n   * A custom renderer, if any.\n   */\n  renderer?: DefaultEntityPresentationApiRenderer;\n}\n\ninterface CacheEntry {\n  updatedAt: number;\n  entity: Entity | undefined;\n}\n\n/**\n * Default implementation of the {@link @backstage/plugin-catalog-react#EntityPresentationApi}.\n *\n * @public\n */\nexport class DefaultEntityPresentationApi implements EntityPresentationApi {\n  /**\n   * Creates a new presentation API that does not reach out to the catalog.\n   */\n  static createLocal(): EntityPresentationApi {\n    return new DefaultEntityPresentationApi({\n      renderer: createDefaultRenderer({ async: false }),\n    });\n  }\n\n  /**\n   * Creates a new presentation API that calls out to the catalog as needed to\n   * get additional information about entities.\n   */\n  static create(\n    options: DefaultEntityPresentationApiOptions,\n  ): EntityPresentationApi {\n    return new DefaultEntityPresentationApi(options);\n  }\n\n  // This cache holds on to all entity data ever loaded, no matter how old. Each\n  // entry is tagged with a timestamp of when it was inserted. We use this map\n  // to be able to always render SOME data even though the information is old.\n  // Entities change very rarely, so it's likely that the rendered information\n  // was perfectly fine in the first place.\n  readonly #cache: Map<string, CacheEntry>;\n  readonly #cacheTtlMs: number;\n  readonly #loader: DataLoader<string, Entity | undefined> | undefined;\n  readonly #kindIcons: Record<string, IconComponent>; // lowercased kinds\n  readonly #renderer: DefaultEntityPresentationApiRenderer;\n\n  private constructor(options: DefaultEntityPresentationApiOptions) {\n    const cacheTtl = options.cacheTtl ?? DEFAULT_CACHE_TTL;\n    const batchDelay = options.batchDelay ?? DEFAULT_BATCH_DELAY;\n    const renderer = options.renderer ?? createDefaultRenderer({ async: true });\n\n    const kindIcons: Record<string, IconComponent> = {};\n    Object.entries(DEFAULT_ICONS).forEach(([kind, icon]) => {\n      kindIcons[kind.toLocaleLowerCase('en-US')] = icon;\n    });\n    Object.entries(options.kindIcons ?? {}).forEach(([kind, icon]) => {\n      kindIcons[kind.toLocaleLowerCase('en-US')] = icon;\n    });\n\n    if (renderer.async) {\n      if (!options.catalogApi) {\n        throw new TypeError(`Asynchronous rendering requires a catalog API`);\n      }\n      this.#loader = this.#createLoader({\n        cacheTtl,\n        batchDelay,\n        renderer,\n        catalogApi: options.catalogApi,\n      });\n    }\n\n    this.#cacheTtlMs = durationToMilliseconds(cacheTtl);\n    this.#cache = new Map();\n    this.#kindIcons = kindIcons;\n    this.#renderer = renderer;\n  }\n\n  /** {@inheritdoc @backstage/plugin-catalog-react#EntityPresentationApi.forEntity} */\n  forEntity(\n    entityOrRef: Entity | string,\n    context?: {\n      defaultKind?: string;\n      defaultNamespace?: string;\n    },\n  ): EntityRefPresentation {\n    const { entityRef, kind, entity, needsLoad } =\n      this.#getEntityForInitialRender(entityOrRef);\n\n    // Make a wrapping helper for rendering\n    const render = (options: {\n      loading: boolean;\n      entity?: Entity;\n    }): EntityRefPresentationSnapshot => {\n      const { snapshot } = this.#renderer.render({\n        entityRef: entityRef,\n        loading: options.loading,\n        entity: options.entity,\n        context: context || {},\n      });\n      return {\n        ...snapshot,\n        entityRef: entityRef,\n        Icon: this.#maybeFallbackIcon(snapshot.Icon, kind),\n      };\n    };\n\n    // First the initial render\n    let initialSnapshot: EntityRefPresentationSnapshot;\n    try {\n      initialSnapshot = render({\n        loading: needsLoad,\n        entity: entity,\n      });\n    } catch {\n      // This is what gets presented if the renderer throws an error\n      initialSnapshot = {\n        primaryTitle: entityRef,\n        entityRef: entityRef,\n      };\n    }\n\n    if (!needsLoad) {\n      return {\n        snapshot: initialSnapshot,\n        promise: Promise.resolve(initialSnapshot),\n      };\n    }\n\n    // Load the entity and render it\n    const maybeUpdatedSnapshot = Promise.resolve()\n      .then(() => {\n        return this.#loader?.load(entityRef);\n      })\n      .then(newEntity => {\n        // We re-render no matter if we get back a new entity or the old\n        // one or nothing, because of the now false loading state - in\n        // case the renderer outputs different data depending on that\n        return render({\n          loading: false,\n          entity: newEntity ?? entity,\n        });\n      })\n      .catch(() => {\n        // Intentionally ignored - we do not propagate errors to the\n        // caller here. The presentation API should be error free and\n        // always return SOMETHING that makes sense to render, and we have\n        // already ensured above that the initial snapshot was that.\n        return undefined;\n      });\n\n    const observable = new ObservableImpl<EntityRefPresentationSnapshot>(\n      subscriber => {\n        let aborted = false;\n\n        maybeUpdatedSnapshot\n          .then(updatedSnapshot => {\n            if (updatedSnapshot) {\n              subscriber.next(updatedSnapshot);\n            }\n          })\n          .finally(() => {\n            if (!aborted) {\n              subscriber.complete();\n            }\n          });\n\n        return () => {\n          aborted = true;\n        };\n      },\n    );\n\n    const promise = maybeUpdatedSnapshot.then(updatedSnapshot => {\n      return updatedSnapshot ?? initialSnapshot;\n    });\n\n    return {\n      snapshot: initialSnapshot,\n      update$: observable,\n      promise: promise,\n    };\n  }\n\n  #getEntityForInitialRender(entityOrRef: Entity | string): {\n    entity: Entity | undefined;\n    kind: string;\n    entityRef: string;\n    needsLoad: boolean;\n  } {\n    // If we were given an entity in the first place, we use it for a single\n    // pass of rendering and assume that it's up to date and not partial (i.e.\n    // we expect that it wasn't fetched in such a way that the required fields\n    // of the renderer were excluded)\n    if (typeof entityOrRef !== 'string') {\n      return {\n        entity: entityOrRef,\n        kind: entityOrRef.kind,\n        entityRef: stringifyEntityRef(entityOrRef),\n        needsLoad: false,\n      };\n    }\n\n    const cached = this.#cache.get(entityOrRef);\n    const cachedEntity: Entity | undefined = cached?.entity;\n    const cacheNeedsUpdate =\n      !cached || Date.now() - cached.updatedAt > this.#cacheTtlMs;\n    const needsLoad =\n      cacheNeedsUpdate &&\n      this.#renderer.async !== false &&\n      this.#loader !== undefined;\n\n    return {\n      entity: cachedEntity,\n      kind: parseEntityRef(entityOrRef).kind,\n      entityRef: entityOrRef,\n      needsLoad,\n    };\n  }\n\n  #createLoader(options: {\n    catalogApi: CatalogApi;\n    cacheTtl: HumanDuration;\n    batchDelay: HumanDuration;\n    renderer: DefaultEntityPresentationApiRenderer;\n  }): DataLoader<string, Entity | undefined> {\n    const cacheTtlMs = durationToMilliseconds(options.cacheTtl);\n    const batchDelayMs = durationToMilliseconds(options.batchDelay);\n\n    return new DataLoader(\n      async (entityRefs: readonly string[]) => {\n        const { items } = await options.catalogApi!.getEntitiesByRefs({\n          entityRefs: entityRefs as string[],\n        });\n\n        const now = Date.now();\n        entityRefs.forEach((entityRef, index) => {\n          this.#cache.set(entityRef, {\n            updatedAt: now,\n            entity: items[index],\n          });\n        });\n\n        return items;\n      },\n      {\n        name: 'DefaultEntityPresentationApi',\n        // This cache is the one that the data loader uses internally for\n        // memoizing requests; essentially what it achieves is that multiple\n        // requests for the same entity ref will be batched up into a single\n        // request and then the resulting promises are held on to. We put an\n        // expiring map here, which makes it so that it re-fetches data with the\n        // expiry cadence of that map. Otherwise it would only fetch a given ref\n        // once and then never try again. This cache does therefore not fulfill\n        // the same purpose as the one that is in the root of the class.\n        cacheMap: new ExpiryMap(cacheTtlMs),\n        maxBatchSize: 100,\n        batchScheduleFn: batchDelayMs\n          ? cb => setTimeout(cb, batchDelayMs)\n          : undefined,\n      },\n    );\n  }\n\n  #maybeFallbackIcon(\n    renderedIcon: IconComponent | false | undefined,\n    kind: string,\n  ): IconComponent | false | undefined {\n    if (renderedIcon) {\n      return renderedIcon;\n    } else if (renderedIcon === false) {\n      return false;\n    }\n\n    return this.#kindIcons[kind.toLocaleLowerCase('en-US')];\n  }\n}\n"],"names":[],"mappings":"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"}