import { ANNOTATION_EDIT_URL, parseEntityRef, DEFAULT_NAMESPACE, ANNOTATION_LOCATION, stringifyEntityRef } from '@backstage/catalog-model';
import Card from '@material-ui/core/Card';
import CardContent from '@material-ui/core/CardContent';
import CardHeader from '@material-ui/core/CardHeader';
import Divider from '@material-ui/core/Divider';
import IconButton from '@material-ui/core/IconButton';
import { makeStyles } from '@material-ui/core/styles';
import { Link, AppIcon, HeaderIconLinkRow } from '@backstage/core-components';
import React, { useCallback } from 'react';
import { scmIntegrationsApiRef, ScmIntegrationIcon } from '@backstage/integration-react';
import { useApp, useApi, alertApiRef, errorApiRef, useRouteRef } from '@backstage/core-plugin-api';
import { useEntity, catalogApiRef, getEntitySourceLocation } from '@backstage/plugin-catalog-react';
import { viewTechDocRouteRef, createFromTemplateRouteRef } from '../../routes.esm.js';
import { AboutContent } from './AboutContent.esm.js';
import CachedIcon from '@material-ui/icons/Cached';
import CreateComponentIcon from '@material-ui/icons/AddCircleOutline';
import DocsIcon from '@material-ui/icons/Description';
import EditIcon from '@material-ui/icons/Edit';
import { isTemplateEntityV1beta3 } from '@backstage/plugin-scaffolder-common';
import { useEntityPermission } from '@backstage/plugin-catalog-react/alpha';
import { catalogEntityRefreshPermission } from '@backstage/plugin-catalog-common/alpha';
import { useSourceTemplateCompoundEntityRef } from './hooks.esm.js';

const TECHDOCS_ANNOTATION = "backstage.io/techdocs-ref";
const TECHDOCS_EXTERNAL_ANNOTATION = "backstage.io/techdocs-entity";
const useStyles = makeStyles({
  gridItemCard: {
    display: "flex",
    flexDirection: "column",
    height: "calc(100% - 10px)",
    // for pages without content header
    marginBottom: "10px"
  },
  fullHeightCard: {
    display: "flex",
    flexDirection: "column",
    height: "100%"
  },
  gridItemCardContent: {
    flex: 1
  },
  fullHeightCardContent: {
    flex: 1
  }
});
function AboutCard(props) {
  var _a, _b, _c, _d, _e, _f, _g;
  const { variant } = props;
  const app = useApp();
  const classes = useStyles();
  const { entity } = useEntity();
  const scmIntegrationsApi = useApi(scmIntegrationsApiRef);
  const catalogApi = useApi(catalogApiRef);
  const alertApi = useApi(alertApiRef);
  const errorApi = useApi(errorApiRef);
  const viewTechdocLink = useRouteRef(viewTechDocRouteRef);
  const templateRoute = useRouteRef(createFromTemplateRouteRef);
  const sourceTemplateRef = useSourceTemplateCompoundEntityRef(entity);
  const { allowed: canRefresh } = useEntityPermission(
    catalogEntityRefreshPermission
  );
  const entitySourceLocation = getEntitySourceLocation(
    entity,
    scmIntegrationsApi
  );
  const entityMetadataEditUrl = (_a = entity.metadata.annotations) == null ? void 0 : _a[ANNOTATION_EDIT_URL];
  let techdocsRef;
  if ((_b = entity.metadata.annotations) == null ? void 0 : _b[TECHDOCS_EXTERNAL_ANNOTATION]) {
    try {
      techdocsRef = parseEntityRef(
        (_c = entity.metadata.annotations) == null ? void 0 : _c[TECHDOCS_EXTERNAL_ANNOTATION]
      );
    } catch {
      techdocsRef = void 0;
    }
  }
  const viewInSource = {
    label: "View Source",
    disabled: !entitySourceLocation,
    icon: /* @__PURE__ */ React.createElement(ScmIntegrationIcon, { type: entitySourceLocation == null ? void 0 : entitySourceLocation.integrationType }),
    href: entitySourceLocation == null ? void 0 : entitySourceLocation.locationTargetUrl
  };
  const viewInTechDocs = {
    label: "View TechDocs",
    disabled: !(((_d = entity.metadata.annotations) == null ? void 0 : _d[TECHDOCS_ANNOTATION]) || ((_e = entity.metadata.annotations) == null ? void 0 : _e[TECHDOCS_EXTERNAL_ANNOTATION])) || !viewTechdocLink,
    icon: /* @__PURE__ */ React.createElement(DocsIcon, null),
    href: viewTechdocLink && (techdocsRef ? viewTechdocLink({
      namespace: techdocsRef.namespace || DEFAULT_NAMESPACE,
      kind: techdocsRef.kind,
      name: techdocsRef.name
    }) : viewTechdocLink({
      namespace: entity.metadata.namespace || DEFAULT_NAMESPACE,
      kind: entity.kind,
      name: entity.metadata.name
    }))
  };
  const subHeaderLinks = [viewInSource, viewInTechDocs];
  if (isTemplateEntityV1beta3(entity)) {
    const Icon = (_f = app.getSystemIcon("scaffolder")) != null ? _f : CreateComponentIcon;
    const launchTemplate = {
      label: "Launch Template",
      icon: /* @__PURE__ */ React.createElement(Icon, null),
      disabled: !templateRoute,
      href: templateRoute && templateRoute({
        templateName: entity.metadata.name,
        namespace: entity.metadata.namespace || DEFAULT_NAMESPACE
      })
    };
    subHeaderLinks.push(launchTemplate);
  }
  let cardClass = "";
  if (variant === "gridItem") {
    cardClass = classes.gridItemCard;
  } else if (variant === "fullHeight") {
    cardClass = classes.fullHeightCard;
  }
  let cardContentClass = "";
  if (variant === "gridItem") {
    cardContentClass = classes.gridItemCardContent;
  } else if (variant === "fullHeight") {
    cardContentClass = classes.fullHeightCardContent;
  }
  const entityLocation = (_g = entity.metadata.annotations) == null ? void 0 : _g[ANNOTATION_LOCATION];
  const allowRefresh = (entityLocation == null ? void 0 : entityLocation.startsWith("url:")) || (entityLocation == null ? void 0 : entityLocation.startsWith("file:"));
  const refreshEntity = useCallback(async () => {
    try {
      await catalogApi.refreshEntity(stringifyEntityRef(entity));
      alertApi.post({
        message: "Refresh scheduled",
        severity: "info",
        display: "transient"
      });
    } catch (e) {
      errorApi.post(e);
    }
  }, [catalogApi, alertApi, errorApi, entity]);
  return /* @__PURE__ */ React.createElement(Card, { className: cardClass }, /* @__PURE__ */ React.createElement(
    CardHeader,
    {
      title: "About",
      action: /* @__PURE__ */ React.createElement(React.Fragment, null, allowRefresh && canRefresh && /* @__PURE__ */ React.createElement(
        IconButton,
        {
          "aria-label": "Refresh",
          title: "Schedule entity refresh",
          onClick: refreshEntity
        },
        /* @__PURE__ */ React.createElement(CachedIcon, null)
      ), /* @__PURE__ */ React.createElement(
        IconButton,
        {
          component: Link,
          "aria-label": "Edit",
          disabled: !entityMetadataEditUrl,
          title: "Edit Metadata",
          to: entityMetadataEditUrl != null ? entityMetadataEditUrl : "#"
        },
        /* @__PURE__ */ React.createElement(EditIcon, null)
      ), sourceTemplateRef && templateRoute && /* @__PURE__ */ React.createElement(
        IconButton,
        {
          component: Link,
          title: "Create something similar",
          to: templateRoute({
            namespace: sourceTemplateRef.namespace,
            templateName: sourceTemplateRef.name
          })
        },
        /* @__PURE__ */ React.createElement(AppIcon, { id: "scaffolder" })
      )),
      subheader: /* @__PURE__ */ React.createElement(HeaderIconLinkRow, { links: subHeaderLinks })
    }
  ), /* @__PURE__ */ React.createElement(Divider, null), /* @__PURE__ */ React.createElement(CardContent, { className: cardContentClass }, /* @__PURE__ */ React.createElement(AboutContent, { entity })));
}

export { AboutCard };
//# sourceMappingURL=AboutCard.esm.js.map
