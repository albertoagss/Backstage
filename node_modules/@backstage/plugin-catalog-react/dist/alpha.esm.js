import { createExtensionDataRef, createSchemaFromZod, createExtension, coreExtensionData, ExtensionBoundary } from '@backstage/frontend-plugin-api';
import React, { lazy } from 'react';
export { useEntityPermission } from './hooks/useEntityPermission.esm.js';
import '@backstage/catalog-model';
export { isOwnerOf } from './utils/isOwnerOf.esm.js';

const catalogExtensionData = {
  entityContentTitle: createExtensionDataRef(
    "catalog.entity-content-title"
  ),
  entityFilterFunction: createExtensionDataRef(
    "catalog.entity-filter-function"
  ),
  entityFilterExpression: createExtensionDataRef(
    "catalog.entity-filter-expression"
  )
};
function createEntityCardExtension(options) {
  var _a, _b;
  const configSchema = "configSchema" in options ? options.configSchema : createSchemaFromZod(
    (z) => z.object({
      filter: z.string().optional()
    })
  );
  return createExtension({
    kind: "entity-card",
    namespace: options.namespace,
    name: options.name,
    attachTo: (_a = options.attachTo) != null ? _a : {
      id: "entity-content:catalog/overview",
      input: "cards"
    },
    disabled: (_b = options.disabled) != null ? _b : true,
    output: {
      element: coreExtensionData.reactElement,
      filterFunction: catalogExtensionData.entityFilterFunction.optional(),
      filterExpression: catalogExtensionData.entityFilterExpression.optional()
    },
    inputs: options.inputs,
    configSchema,
    factory({ config, inputs, node }) {
      const ExtensionComponent = lazy(
        () => options.loader({ inputs, config }).then((element) => ({ default: () => element }))
      );
      return {
        element: /* @__PURE__ */ React.createElement(ExtensionBoundary, { node }, /* @__PURE__ */ React.createElement(ExtensionComponent, null)),
        ...mergeFilters({ config, options })
      };
    }
  });
}
function createEntityContentExtension(options) {
  var _a, _b;
  return createExtension({
    kind: "entity-content",
    namespace: options.namespace,
    name: options.name,
    attachTo: (_a = options.attachTo) != null ? _a : {
      id: "page:catalog/entity",
      input: "contents"
    },
    disabled: (_b = options.disabled) != null ? _b : true,
    output: {
      element: coreExtensionData.reactElement,
      path: coreExtensionData.routePath,
      routeRef: coreExtensionData.routeRef.optional(),
      title: catalogExtensionData.entityContentTitle,
      filterFunction: catalogExtensionData.entityFilterFunction.optional(),
      filterExpression: catalogExtensionData.entityFilterExpression.optional()
    },
    inputs: options.inputs,
    configSchema: createSchemaFromZod(
      (z) => z.object({
        path: z.string().default(options.defaultPath),
        title: z.string().default(options.defaultTitle),
        filter: z.string().optional()
      })
    ),
    factory({ config, inputs, node }) {
      const ExtensionComponent = lazy(
        () => options.loader({ inputs }).then((element) => ({ default: () => element }))
      );
      return {
        path: config.path,
        title: config.title,
        routeRef: options.routeRef,
        element: /* @__PURE__ */ React.createElement(ExtensionBoundary, { node, routable: true }, /* @__PURE__ */ React.createElement(ExtensionComponent, null)),
        ...mergeFilters({ config, options })
      };
    }
  });
}
function mergeFilters(inputs) {
  const { options, config } = inputs;
  if (config.filter) {
    return { filterExpression: config.filter };
  } else if (typeof options.filter === "string") {
    return { filterExpression: options.filter };
  } else if (typeof options.filter === "function") {
    return { filterFunction: options.filter };
  }
  return {};
}

export { catalogExtensionData, createEntityCardExtension, createEntityContentExtension };
//# sourceMappingURL=alpha.esm.js.map
