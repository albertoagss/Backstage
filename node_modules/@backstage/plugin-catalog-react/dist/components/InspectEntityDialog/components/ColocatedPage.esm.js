import { ANNOTATION_LOCATION, ANNOTATION_ORIGIN_LOCATION, stringifyEntityRef } from '@backstage/catalog-model';
import { Progress, ResponseErrorPanel } from '@backstage/core-components';
import { useApi } from '@backstage/core-plugin-api';
import DialogContentText from '@material-ui/core/DialogContentText';
import List from '@material-ui/core/List';
import ListItem from '@material-ui/core/ListItem';
import { makeStyles } from '@material-ui/core/styles';
import Alert from '@material-ui/lab/Alert';
import React from 'react';
import useAsync from 'react-use/esm/useAsync';
import { catalogApiRef } from '../../../api.esm.js';
import { EntityRefLink } from '../../EntityRefLink/EntityRefLink.esm.js';
import 'lodash/get';
import { KeyValueListItem, ListItemText } from './common.esm.js';

const useStyles = makeStyles({
  root: {
    display: "flex",
    flexDirection: "column"
  }
});
function useColocated(entity) {
  var _a, _b;
  const catalogApi = useApi(catalogApiRef);
  const currentEntityRef = stringifyEntityRef(entity);
  const location = (_a = entity.metadata.annotations) == null ? void 0 : _a[ANNOTATION_LOCATION];
  const origin = (_b = entity.metadata.annotations) == null ? void 0 : _b[ANNOTATION_ORIGIN_LOCATION];
  const { loading, error, value } = useAsync(async () => {
    if (!location && !origin) {
      return [];
    }
    const response = await catalogApi.getEntities({
      filter: [
        ...location ? [{ [`metadata.annotations.${ANNOTATION_LOCATION}`]: location }] : [],
        ...origin ? [{ [`metadata.annotations.${ANNOTATION_ORIGIN_LOCATION}`]: origin }] : []
      ]
    });
    return response.items;
  }, [location, origin]);
  return {
    loading,
    error,
    location,
    originLocation: origin,
    colocatedEntities: value == null ? void 0 : value.filter(
      (colocated) => stringifyEntityRef(colocated) !== currentEntityRef
    )
  };
}
function EntityList(props) {
  return /* @__PURE__ */ React.createElement(List, { dense: true }, props.header && /* @__PURE__ */ React.createElement(KeyValueListItem, { key: "header", entry: props.header }), props.entities.map((entity) => /* @__PURE__ */ React.createElement(ListItem, { key: stringifyEntityRef(entity) }, /* @__PURE__ */ React.createElement(ListItemText, { primary: /* @__PURE__ */ React.createElement(EntityRefLink, { entityRef: entity }) }))));
}
function Contents(props) {
  const { entity } = props;
  const { loading, error, location, originLocation, colocatedEntities } = useColocated(entity);
  if (loading) {
    return /* @__PURE__ */ React.createElement(Progress, null);
  } else if (error) {
    return /* @__PURE__ */ React.createElement(ResponseErrorPanel, { error });
  }
  if (!location && !originLocation) {
    return /* @__PURE__ */ React.createElement(Alert, { severity: "warning" }, "Entity had no location information.");
  } else if (!(colocatedEntities == null ? void 0 : colocatedEntities.length)) {
    return /* @__PURE__ */ React.createElement(Alert, { severity: "info" }, "There were no other entities on this location.");
  }
  if (location === originLocation) {
    return /* @__PURE__ */ React.createElement(EntityList, { entities: colocatedEntities });
  }
  const atLocation = colocatedEntities.filter(
    (e) => {
      var _a;
      return ((_a = e.metadata.annotations) == null ? void 0 : _a[ANNOTATION_LOCATION]) === location;
    }
  );
  const atOrigin = colocatedEntities.filter(
    (e) => {
      var _a;
      return ((_a = e.metadata.annotations) == null ? void 0 : _a[ANNOTATION_ORIGIN_LOCATION]) === originLocation;
    }
  );
  return /* @__PURE__ */ React.createElement(React.Fragment, null, atLocation.length > 0 && /* @__PURE__ */ React.createElement(
    EntityList,
    {
      entities: atLocation,
      header: ["At the same location", location]
    }
  ), atOrigin.length > 0 && /* @__PURE__ */ React.createElement(
    EntityList,
    {
      entities: atOrigin,
      header: ["At the same origin", originLocation]
    }
  ));
}
function ColocatedPage(props) {
  const classes = useStyles();
  return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(DialogContentText, { variant: "h2" }, "Colocated"), /* @__PURE__ */ React.createElement(DialogContentText, null, "These are the entities that are colocated with this entity - as in, they originated from the same data source (e.g. came from the same YAML file), or from the same origin (e.g. the originally registered URL)."), /* @__PURE__ */ React.createElement("div", { className: classes.root }, /* @__PURE__ */ React.createElement(Contents, { entity: props.entity })));
}

export { ColocatedPage };
//# sourceMappingURL=ColocatedPage.esm.js.map
